@page "/"
@rendermode InteractiveServer
@using System.IO
@using ComparisonTool.Core.Comparison
@using ComparisonTool.Core.Comparison.Analysis
@using ComparisonTool.Core.Comparison.Configuration
@using ComparisonTool.Core.Comparison.Results
@using ComparisonTool.Core.Serialization
@using ComparisonTool.Core.Utilities
@using KellermanSoftware.CompareNetObjects
@using Microsoft.AspNetCore.Components
@implements IDisposable
@inject IXmlDeserializationService DeserializationService
@inject IComparisonConfigurationService ConfigService
@inject IComparisonService ComparisonService
@inject IFileUtilities FileUtilities
@inject IJSRuntime JSRuntime
@inject ILogger<Home> Logger

<h1>XML Comparison Tool</h1>

<div class="row mt-4">
    <div class="col-md-6">
        <FileSelector 
            ModelNames="@DeserializationService.GetRegisteredModelNames()"
            SelectedModelName="@SelectedModelName"
            OnModelNameChanged="@(name => SelectedModelName = name)"
            Folder1Files="@Folder1Files"
            OnFolder1FilesChanged="@HandleFolder1FilesChanged"
            Folder2Files="@Folder2Files"
            OnFolder2FilesChanged="@HandleFolder2FilesChanged" />
    </div>
    
    <div class="col-md-6">
        <ComparisonConfigurationPanel
            IgnoreCollectionOrder="@IgnoreCollectionOrder"
            OnIgnoreCollectionOrderChanged="@(value => IgnoreCollectionOrder = value)"
            IgnoreStringCase="@IgnoreStringCase"
            OnIgnoreStringCaseChanged="@(value => IgnoreStringCase = value)"
            EnablePatternAnalysis="@EnablePatternAnalysis"
            OnEnablePatternAnalysisChanged="@(value => EnablePatternAnalysis = value)"
            EnableSemanticAnalysis="@EnableSemanticAnalysis"
            OnEnableSemanticAnalysisChanged="@(value => EnableSemanticAnalysis = value)"
            IgnoreRules="@IgnoreRules" 
            OnIgnoreRuleAdded="@AddIgnoreRule"
            OnIgnoreRuleRemoved="@RemoveIgnoreRule"
            ModelType="@GetSelectedModelType()"
            OnPropertySelectorOpened="@OpenPropertySelector"
            OnRunComparison="@RunFolderComparison"
            CanRunComparison="@CanRunFolderComparison" />
    </div>
</div>

@if (IsComparing)
{
    <LoadingIndicator Message="Comparing XML files..." />
}

@if (FolderComparisonResult != null)
{
    <FileComparisonResults 
        Result="@FolderComparisonResult"
        SelectedPairIndex="@SelectedPairIndex" 
        OnPairSelected="@SelectPairResult" 
        OnExportAll="@ExportAllFolderResults" />
}

@if (PatternAnalysis != null && (ShowPatternSummary || EnablePatternAnalysis))
{
    <PatternAnalysisPanel 
        Analysis="@PatternAnalysis" 
        ShowSummary="@ShowPatternSummary"
        OnToggleSummary="@(() => ShowPatternSummary = !ShowPatternSummary)"
        OnExportAnalysis="@ExportPatternAnalysisReport" />
}

@if (SemanticAnalysis != null && (ShowPatternSummary || EnablePatternAnalysis))
{
    <SemanticGroupsPanel 
        Analysis="@SemanticAnalysis"
        OnExportAnalysis="@ExportSemanticAnalysisReport" />
}

@if (FolderComparisonResult != null && SelectedPairIndex >= 0 && DifferenceSummary != null)
{
    <DetailedDifferencesView 
        SelectedPair="@FolderComparisonResult.FilePairResults[SelectedPairIndex]"
        DifferenceSummary="@DifferenceSummary"
        ComparisonResult="@ComparisonResult"
        ShowAllDifferences="@ShowAllDifferences"
        OnToggleShowAll="@ToggleShowAllDifferences"
        OnExportResults="@ExportFolderResults" />
}

<HierarchicalPropertySelector @ref="propertySelector"
                          ModelType="@GetSelectedModelType()"
                          IgnoredProperties="IgnoreRules"
                          OnPropertyAdded="AddIgnoreRule"
                          OnPropertyRemoved="propertyPath => RemoveIgnoreRule(IgnoreRules.FirstOrDefault(r => r.PropertyPath == propertyPath))" />

@code {
    private string SelectedModelName { get; set; }
    private bool IgnoreCollectionOrder { get; set; } = false;
    private bool IgnoreStringCase { get; set; } = false;
    private List<IgnoreRule> IgnoreRules { get; set; } = new List<IgnoreRule>();
    private bool IsComparing { get; set; } = false;
    private ComparisonResult ComparisonResult { get; set; }
    private DifferenceSummary DifferenceSummary { get; set; }
    private bool ShowAllDifferences { get; set; } = false;
    private List<(MemoryStream Stream, string FileName)> Folder1Files { get; set; } = new List<(MemoryStream, string)>();
    private List<(MemoryStream Stream, string FileName)> Folder2Files { get; set; } = new List<(MemoryStream, string)>();
    private MultiFolderComparisonResult FolderComparisonResult { get; set; }
    private int SelectedPairIndex { get; set; } = -1;
    private ComparisonPatternAnalysis PatternAnalysis { get; set; }
    private bool ShowPatternSummary { get; set; } = false;
    private bool EnablePatternAnalysis { get; set; } = true;
    private SemanticDifferenceAnalysis SemanticAnalysis { get; set; }
    private CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
    private HierarchicalPropertySelector propertySelector;
    private bool EnableSemanticAnalysis { get; set; } = true;

    private bool CanRunFolderComparison =>
        !string.IsNullOrEmpty(SelectedModelName) &&
        Folder1Files.Count > 0 &&
        Folder2Files.Count > 0;

    protected override void OnInitialized()
    {
        try
        {
            SelectedModelName = DeserializationService.GetRegisteredModelNames().FirstOrDefault();

            IgnoreCollectionOrder = ConfigService.GetIgnoreCollectionOrder();
            IgnoreStringCase = ConfigService.GetIgnoreStringCase();

            foreach (var prop in ConfigService.GetIgnoredProperties())
            {
                IgnoreRules.Add(new IgnoreRule
                    {
                        PropertyPath = prop,
                        IgnoreCompletely = true
                    });
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing component");
        }
    }

    public void Dispose()
    {
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
    }

    private Type GetSelectedModelType()
    {
        if (string.IsNullOrEmpty(SelectedModelName))
            return null;

        try
        {
            return DeserializationService.GetModelType(SelectedModelName);
        }
        catch
        {
            return null;
        }
    }

    private void HandleFolder1FilesChanged(List<(MemoryStream Stream, string FileName)> files)
    {
        Folder1Files = files;
    }

    private void HandleFolder2FilesChanged(List<(MemoryStream Stream, string FileName)> files)
    {
        Folder2Files = files;
    }

    private async Task OpenPropertySelector()
    {
        await propertySelector.ShowAsync();
    }

    private void AddIgnoreRule(IgnoreRule rule)
    {
        var existingRule = IgnoreRules.FirstOrDefault(r => r.PropertyPath == rule.PropertyPath);
        if (existingRule != null)
        {
            IgnoreRules.Remove(existingRule);
        }

        IgnoreRules.Add(rule);

        if (rule.IgnoreCompletely)
        {
            ConfigService.IgnoreProperty(rule.PropertyPath);
        }
        else
        {
            ConfigService.AddIgnoreRule(rule);
        }
    }

    private void RemoveIgnoreRule(IgnoreRule rule)
    {
        if (rule == null) return;

        IgnoreRules.Remove(rule);

        // Also remove from the service
        if (rule.IgnoreCompletely)
        {
            ConfigService.RemoveIgnoredProperty(rule.PropertyPath);
        }
    }

    private async Task RunFolderComparison()
    {
        if (!CanRunFolderComparison)
            return;

        try
        {
            IsComparing = true;
            FolderComparisonResult = null;
            SelectedPairIndex = -1;
            PatternAnalysis = null;
            ShowPatternSummary = false;

            await _cancellationTokenSource.CancelAsync();
            _cancellationTokenSource.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();
            var cancellationToken = _cancellationTokenSource.Token;

            ConfigService.SetIgnoreCollectionOrder(IgnoreCollectionOrder);
            ConfigService.SetIgnoreStringCase(IgnoreStringCase);

            foreach (var rule in IgnoreRules)
            {
                ConfigService.AddIgnoreRule(rule);
            }

            ConfigService.ApplyConfiguredSettings();

            var folder1FilesList = Folder1Files
                .Select(f => ((Stream)f.Stream, f.FileName))
                .ToList();

            var folder2FilesList = Folder2Files
                .Select(f => ((Stream)f.Stream, f.FileName))
                .ToList();

            FolderComparisonResult = await ComparisonService.CompareFoldersAsync(
                folder1FilesList,
                folder2FilesList,
                SelectedModelName,
                cancellationToken);

            if (!FolderComparisonResult.AllEqual && FolderComparisonResult.FilePairResults.Count > 0)
            {
                SelectPairResult(0);
            }

            if (!FolderComparisonResult.AllEqual && FolderComparisonResult.FilePairResults.Count > 1 && EnablePatternAnalysis)
            {
                await GeneratePatternAnalysis();
            }

            if (!FolderComparisonResult.AllEqual && FolderComparisonResult.FilePairResults.Count > 1 && EnablePatternAnalysis)
            {
                await GeneratePatternAnalysis();

                if (PatternAnalysis != null)
                {
                    await GenerateSemanticAnalysis();
                }
            }
        }
        catch (OperationCanceledException)
        {
            Logger.LogInformation("Comparison operation was canceled");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error comparing files: {Message}", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error comparing files: {ex.Message}");
        }
        finally
        {
            IsComparing = false;
            StateHasChanged();
        }
    }

    private void SelectPairResult(int index)
    {
        if (index >= 0 && index < FolderComparisonResult?.FilePairResults.Count)
        {
            SelectedPairIndex = index;

            var selectedPair = FolderComparisonResult.FilePairResults[index];
            ComparisonResult = selectedPair.Result;
            DifferenceSummary = selectedPair.Summary;
        }
    }

    private void ToggleShowAllDifferences()
    {
        ShowAllDifferences = !ShowAllDifferences;
    }

    private async Task GeneratePatternAnalysis()
    {
        if (FolderComparisonResult == null || FolderComparisonResult.FilePairResults.Count <= 1)
            return;

        try
        {
            IsComparing = true;

            var cancellationToken = _cancellationTokenSource.Token;

            PatternAnalysis = await ComparisonService.AnalyzePatternsAsync(
                FolderComparisonResult,
                cancellationToken);

            ShowPatternSummary = true;
        }
        catch (OperationCanceledException)
        {
            Logger.LogInformation("Pattern analysis operation was canceled");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error generating pattern analysis: {Message}", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error generating pattern analysis: {ex.Message}");
        }
        finally
        {
            IsComparing = false;
            StateHasChanged();
        }
    }

    private async Task ExportFolderResults()
    {
        if (FolderComparisonResult == null || SelectedPairIndex < 0)
            return;

        try
        {
            var selectedPair = FolderComparisonResult.FilePairResults[SelectedPairIndex];
            var file1Name = Path.GetFileNameWithoutExtension(selectedPair.File1Name);
            var file2Name = Path.GetFileNameWithoutExtension(selectedPair.File2Name);

            var headerInfo = $"# Comparison Report\n\n" +
                          $"V1 file: **{selectedPair.File1Name}**\n\n" +
                          $"V2 file: **{selectedPair.File2Name}**\n\n" +
                          $"---\n\n";

            var report = FileUtilities.GenerateReportMarkdown(selectedPair.Summary, headerInfo);

            await JSRuntime.InvokeVoidAsync(
                "saveAsFile",
                $"comparison-{file1Name}-vs-{file2Name}.md",
                "text/markdown",
                report);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error exporting folder results: {Message}", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error exporting results: {ex.Message}");
        }
    }

    private async Task ExportAllFolderResults()
    {
        if (FolderComparisonResult == null || FolderComparisonResult.FilePairResults.Count == 0)
            return;

        try
        {
            string report = FileUtilities.GenerateFolderComparisonReport(FolderComparisonResult);

            await JSRuntime.InvokeVoidAsync(
                "saveAsFile",
                "folder-comparison-report.md",
                "text/markdown",
                report);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error exporting all folder results: {Message}", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error exporting results: {ex.Message}");
        }
    }

    private async Task ExportPatternAnalysisReport(string filename)
    {
        if (PatternAnalysis == null)
            return;

        try
        {
            var report = FileUtilities.GeneratePatternAnalysisReport(PatternAnalysis);

            await JSRuntime.InvokeVoidAsync(
                "saveAsFile",
                filename,
                "text/markdown",
                report);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error exporting pattern analysis: {Message}", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error exporting pattern analysis: {ex.Message}");
        }
    }

    private async Task GenerateSemanticAnalysis()
    {
        if (FolderComparisonResult == null || PatternAnalysis == null)
            return;
        
        try
        {
            IsComparing = true;
        
            var cancellationToken = _cancellationTokenSource.Token;
        
            SemanticAnalysis = await ComparisonService.AnalyzeSemanticDifferencesAsync(
                FolderComparisonResult,
                PatternAnalysis,
                cancellationToken);
        }
        catch (OperationCanceledException)
        {
            Logger.LogInformation("Semantic analysis operation was canceled");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error generating semantic analysis: {Message}", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error generating semantic analysis: {ex.Message}");
        }
        finally
        {
            IsComparing = false;
            StateHasChanged();
        }
    }

    private async Task ExportSemanticAnalysisReport(string filename)
    {
        if (SemanticAnalysis == null)
            return;
        
        try
        {
            var report = FileUtilities.GenerateSemanticAnalysisReport(SemanticAnalysis);
        
            await JSRuntime.InvokeVoidAsync(
                "saveAsFile",
                filename,
                "text/markdown",
                report);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error exporting semantic analysis: {Message}", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error exporting semantic analysis: {ex.Message}");
        }
    }
}
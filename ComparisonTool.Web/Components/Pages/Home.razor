@rendermode InteractiveServer
@page "/"
@using System.IO
@using System.Text
@using KellermanSoftware.CompareNetObjects
@using ComparisonTool.Core
@using Microsoft.AspNetCore.Components
@inject XmlComparisonService ComparisonService
@inject IJSRuntime JSRuntime

<h1>XML Comparison Tool</h1>

<div class="row mt-4">
    <div class="col-md-6">
        <div class="card">
            <div class="card-header">
                <h5>Step 1: Select XML Files</h5>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label>Select Domain Model:</label>
                    <select class="form-control" @bind="SelectedModelName">
                        @foreach (var modelName in ComparisonService.GetRegisteredModelNames())
                        {
                            <option value="@modelName">@modelName</option>
                        }
                    </select>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group mt-3">
                            <label>V1 Files (select multiple):</label>
                            <InputFile class="form-control" OnChange="HandleFolder1Upload" multiple />

                            @if (Folder1Files.Any())
                            {
                                <div class="mt-2">
                                    <div class="card">
                                        <div class="card-header bg-light">
                                            V1 Files (@Folder1Files.Count)
                                        </div>
                                        <ul class="list-group list-group-flush" style="max-height: 200px; overflow-y: auto;">
                                            @for (int i = 0; i < Folder1Files.Count; i++)
                                            {
                                                var index = i;
                                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                                    <div>
                                                        <small>@Folder1Files[i].FileName</small>
                                                    </div>
                                                    <button class="btn btn-sm btn-danger" @onclick="() => RemoveFolder1File(index)">
                                                        <i class="bi bi-x"></i>
                                                    </button>
                                                </li>
                                            }
                                        </ul>
                                    </div>
                                </div>
                            }
                        </div>
                    </div>

                    <div class="col-md-6">
                        <div class="form-group mt-3">
                            <label>V2 Files (select multiple):</label>
                            <InputFile class="form-control" OnChange="HandleFolder2Upload" multiple />

                            @if (Folder2Files.Any())
                            {
                                <div class="mt-2">
                                    <div class="card">
                                        <div class="card-header bg-light">
                                            V2 Files (@Folder2Files.Count)
                                        </div>
                                        <ul class="list-group list-group-flush" style="max-height: 200px; overflow-y: auto;">
                                            @for (int i = 0; i < Folder2Files.Count; i++)
                                            {
                                                var index = i;
                                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                                    <div>
                                                        <small>@Folder2Files[i].FileName</small>
                                                    </div>
                                                    <button class="btn btn-sm btn-danger" @onclick="() => RemoveFolder2File(index)">
                                                        <i class="bi bi-x"></i>
                                                    </button>
                                                </li>
                                            }
                                        </ul>
                                    </div>
                                </div>
                            }
                        </div>
                    </div>
                </div>

                @if (Folder1Files.Any() && Folder2Files.Any())
                {
                    <div class="alert alert-info mt-3">
                        <strong>Files will be paired for comparison in order.</strong><br />
                        V1 files are sorted by filename, and V2 files are sorted by filename. Each V1 file will be compared with the corresponding V2 file.
                    </div>
                }
            </div>
        </div>
    </div>

    <div class="col-md-6">
        <div class="card">
            <div class="card-header">
                <h5>Step 2: Configure Comparison</h5>
            </div>
            <div class="card-body">
                <div class="form-group form-check">
                    <input type="checkbox" class="form-check-input" id="ignoreOrder"
                           @bind="IgnoreCollectionOrder" />
                    <label class="form-check-label" for="ignoreOrder">
                        Ignore Collection Ordering
                    </label>
                </div>

                <div class="form-group form-check mt-2">
                    <input type="checkbox" class="form-check-input" id="ignoreCase"
                           @bind="IgnoreStringCase" />
                    <label class="form-check-label" for="ignoreCase">
                        Ignore String Case
                    </label>
                </div>

                <div class="form-group mt-3">
                    <label>Properties to Ignore:</label>
                    <button class="btn btn-sm btn-primary ms-2" @onclick="OpenPropertySelector">
                        Configure Properties
                    </button>

                    @if (IgnoreRules.Any())
                    {
                        <div class="mt-2">
                            <div class="card">
                                <div class="card-header bg-light">
                                    Currently Ignored Properties (@IgnoreRules.Count)
                                </div>
                                <ul class="list-group list-group-flush">
                                    @foreach (var rule in IgnoreRules)
                                    {
                                        <li class="list-group-item d-flex justify-content-between align-items-center">
                                            <div>
                                                <span class="me-2">@GetIgnoreRuleDescription(rule)</span>
                                            </div>
                                            <button class="btn btn-sm btn-danger" @onclick="() => RemoveIgnoreRule(rule)">
                                                <i class="bi bi-x"></i>
                                            </button>
                                        </li>
                                    }
                                </ul>
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-info mt-2">
                            No properties are currently being ignored. Click the button to configure.
                        </div>
                    }
                </div>
                
                <div class="form-group form-check mt-2">
                    <input type="checkbox" class="form-check-input" id="enablePatternAnalysis"
                           @bind="EnablePatternAnalysis" />
                    <label class="form-check-label" for="enablePatternAnalysis">
                        Enable Cross-File Pattern Analysis
                    </label>
                    <small class="form-text text-muted d-block">
                        Analyzes common patterns and changes across multiple files. May take longer for large sets of files.
                    </small>
                </div>

                <button class="btn btn-primary mt-3" @onclick="RunFolderComparison"
                        disabled="@(!CanRunFolderComparison)">
                    Run Comparison
                </button>
            </div>
        </div>
    </div>
</div>

@if (IsComparing)
{
    <div class="text-center mt-4">
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p>Comparing XML files...</p>
    </div>
}

@if (FolderComparisonResult != null)
{
    <div class="mt-4">
        <div class="card">
            <div class="card-header bg-light d-flex justify-content-between align-items-center">
                <h5 class="mb-0">V1 vs V2 Comparison Results</h5>
                <button class="btn btn-sm btn-outline-primary" @onclick="ExportAllFolderResults">
                    <i class="bi bi-download me-1"></i> Export All Results
                </button>
            </div>
            <div class="card-body">
                @if (FolderComparisonResult.AllEqual)
                {
                    <div class="alert alert-success">
                        <i class="bi bi-check-circle-fill me-2"></i>
                        All file pairs are identical according to the current comparison rules.
                    </div>
                }
                else
                {
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        Found differences in compared file pairs.
                    </div>

                    <h6>Select a file pair to view detailed comparison:</h6>
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th>V1 File</th>
                                    <th>V2 File</th>
                                    <th>Status</th>
                                    <th>Differences</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
                                @for (int i = 0; i < FolderComparisonResult.FilePairResults.Count; i++)
                                {
                                    var index = i;
                                    var result = FolderComparisonResult.FilePairResults[i];
                                    <tr class="@(index == SelectedPairIndex ? "table-primary" : "")" style="cursor: pointer;" @onclick="() => SelectPairResult(index)">
                                        <td>@result.File1Name</td>
                                        <td>@result.File2Name</td>
                                        <td>
                                            <span class="badge @(result.AreEqual ? "bg-success" : "bg-danger")">
                                                @(result.AreEqual ? "Equal" : "Different")
                                            </span>
                                        </td>
                                        <td>@(result.AreEqual ? "0" : result.Summary.TotalDifferenceCount.ToString())</td>
                                        <td>
                                            <button class="btn btn-sm btn-outline-secondary" @onclick:stopPropagation="true" @onclick="() => SelectPairResult(index)">
                                                View
                                            </button>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                }
            </div>
        </div>
    </div>
}

@if (FolderComparisonResult != null && !FolderComparisonResult.AllEqual && FolderComparisonResult.FilePairResults.Count > 1)
{
    <div class="mt-3 mb-4">
        @if (!EnablePatternAnalysis)
        {
            <button class="btn btn-outline-secondary" @onclick="GeneratePatternAnalysis" disabled="@(PatternAnalysis != null)">
                <i class="bi bi-graph-up me-1"></i> Generate Pattern Analysis
            </button>

            @if (PatternAnalysis != null)
            {
                <span class="text-success ms-2">
                    <i class="bi bi-check-circle"></i> Analysis generated
                </span>
            }
        }

        @if (PatternAnalysis != null)
        {
            <div class="d-inline-block ms-2">
                <button class="btn btn-outline-primary btn-sm" @onclick="() => ShowPatternSummary = !ShowPatternSummary">
                    @if (ShowPatternSummary)
                    {
                        <span><i class="bi bi-chevron-up me-1"></i> Hide Pattern Summary</span>
                    }
                    else
                    {
                        <span><i class="bi bi-chevron-down me-1"></i> Show Pattern Summary</span>
                    }
                </button>
            </div>
        }
    </div>
}

@if (PatternAnalysis != null && ShowPatternSummary)
{
    <div class="mt-3 mb-4">
        <h5>Cross-File Pattern Analysis</h5>
        <PatternSummaryComponent Analysis="PatternAnalysis" OnExportAnalysis="ExportPatternAnalysisReport" />
    </div>
}

@if (FolderComparisonResult != null && SelectedPairIndex >= 0 && DifferenceSummary != null)
{
    <div class="mt-4">
        <div class="card">
            <div class="card-header bg-light d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                    Comparison: @FolderComparisonResult.FilePairResults[SelectedPairIndex].File1Name
                    vs @FolderComparisonResult.FilePairResults[SelectedPairIndex].File2Name
                </h5>
                <button class="btn btn-sm btn-outline-primary" @onclick="ExportFolderResults">
                    <i class="bi bi-download me-1"></i> Export This Result
                </button>
            </div>
            <div class="card-body">
                <EnhancedDifferenceSummary Summary="DifferenceSummary" />
            </div>
        </div>
    </div>

    @if (!DifferenceSummary.AreEqual)
    {
        <div class="mt-4">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Detailed Differences</h5>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="ToggleShowAllDifferences">
                        @(ShowAllDifferences ? "Show Top 100" : "Show All")
                    </button>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>Property</th>
                                    <th>V1 Value (@FolderComparisonResult.FilePairResults[SelectedPairIndex].File1Name)</th>
                                    <th>V2 Value (@FolderComparisonResult.FilePairResults[SelectedPairIndex].File2Name)</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var diff in GetFilteredDifferences())
                                {
                                    <tr>
                                        <td>@diff.PropertyName</td>
                                        <td class="text-danger">@FormatValue(diff.Object1Value)</td>
                                        <td class="text-success">@FormatValue(diff.Object2Value)</td>
                                    </tr>
                                }
                                @if (ComparisonResult.Differences.Count > 100 && !ShowAllDifferences)
                                {
                                    <tr>
                                        <td colspan="3" class="text-center">
                                            <em>And @(ComparisonResult.Differences.Count - 100) more differences...</em>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    }
}

<HierarchicalPropertySelector @ref="propertySelector"
                              ModelType="ComparisonService.GetModelType(SelectedModelName)"
                              IgnoredProperties="IgnoreRules"
                              OnPropertyAdded="AddIgnoreRule"
                              OnPropertyRemoved="propertyPath => RemoveIgnoreRule(IgnoreRules.FirstOrDefault(r => r.PropertyPath == propertyPath))" />
@code {
    // State variables
    private string SelectedModelName { get; set; }
    private string OldFileName { get; set; }
    private string NewFileName { get; set; }
    private MemoryStream OldFileContent { get; set; }
    private MemoryStream NewFileContent { get; set; }
    private bool IgnoreCollectionOrder { get; set; } = false;
    private bool IgnoreStringCase { get; set; } = false;
    private List<IgnoreRule> IgnoreRules { get; set; } = new List<IgnoreRule>();
    private bool IsComparing { get; set; } = false;
    private ComparisonResult ComparisonResult { get; set; }
    private DifferenceSummary DifferenceSummary { get; set; }
    private bool ShowAllDifferences { get; set; } = false;
    private List<(MemoryStream Stream, string FileName)> Folder1Files { get; set; } = new List<(MemoryStream, string)>();
    private List<(MemoryStream Stream, string FileName)> Folder2Files { get; set; } = new List<(MemoryStream, string)>();
    private MultiFolderComparisonResult FolderComparisonResult { get; set; }
    private int SelectedPairIndex { get; set; } = -1;
    private ComparisonPatternAnalysis PatternAnalysis { get; set; }
    private bool ShowPatternSummary { get; set; } = false;
    private bool EnablePatternAnalysis { get; set; } = true; // Default to enabled

    // Property selector
    private HierarchicalPropertySelector propertySelector;

    // Enable the comparison button if both files are loaded
    private bool CanRunComparison =>
        !string.IsNullOrEmpty(SelectedModelName) &&
        OldFileContent != null &&
        NewFileContent != null;

    protected override void OnInitialized()
    {
        // Set initial selection
        SelectedModelName = ComparisonService.GetRegisteredModelNames().FirstOrDefault();

        // Get current configuration settings from the service directly
        IgnoreCollectionOrder = ComparisonService.GetIgnoreCollectionOrder();
        IgnoreStringCase = ComparisonService.GetIgnoreStringCase();

        // Convert simple ignored properties to rules
        foreach (var prop in ComparisonService.GetIgnoredProperties())
        {
            IgnoreRules.Add(new IgnoreRule
                {
                    PropertyPath = prop,
                    IgnoreCompletely = true
                });
        }

        // OldFileContent = LoadFileToMemorySteam("OldFile.xml");
        // NewFileContent = LoadFileToMemorySteam("NewFile.xml");

        StateHasChanged();
    }

    private MemoryStream LoadFileToMemorySteam(string filePath)
    {
        using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
        var memoryStream = new MemoryStream();
        fileStream.CopyTo(memoryStream);
        memoryStream.Position = 0;

        return memoryStream;
    }

    // File handling
    private async Task HandleOldFileUpload(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            OldFileName = file.Name;

            // Create a stream to store the file content
            OldFileContent = new MemoryStream();

            // Copy the file data to the stream
            await file.OpenReadStream(maxAllowedSize: 10485760).CopyToAsync(OldFileContent);
            OldFileContent.Position = 0;

            // Force UI refresh
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading old file: {ex.Message}");
            OldFileName = $"Error: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task HandleNewFileUpload(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            NewFileName = file.Name;

            // Create a stream to store the file content
            NewFileContent = new MemoryStream();

            // Copy the file data to the stream
            await file.OpenReadStream(maxAllowedSize: 10485760).CopyToAsync(NewFileContent);
            NewFileContent.Position = 0;

            // Force UI refresh
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading new file: {ex.Message}");
            NewFileName = $"Error: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task OpenPropertySelector()
    {
        await propertySelector.ShowAsync();
    }

    private void AddIgnoreRule(IgnoreRule rule)
    {
        // Remove any existing rule for this property
        var existingRule = IgnoreRules.FirstOrDefault(r => r.PropertyPath == rule.PropertyPath);
        if (existingRule != null)
        {
            IgnoreRules.Remove(existingRule);
        }

        // Add the new rule
        IgnoreRules.Add(rule);

        // If complete ignore, also add to the service
        if (rule.IgnoreCompletely)
        {
            ComparisonService.IgnoreProperty(rule.PropertyPath);
        }
    }

    private void RemoveIgnoreRule(IgnoreRule rule)
    {
        IgnoreRules.Remove(rule);

        // Also remove from the service
        if (rule.IgnoreCompletely)
        {
            ComparisonService.RemoveIgnoredProperty(rule.PropertyPath);
        }
    }

    private string GetIgnoreRuleDescription(IgnoreRule rule)
    {
        var description = rule.PropertyPath;

        if (rule.IgnoreCompletely)
        {
            description += " (Ignored completely)";
        }
        else
        {
            var options = new List<string>();

            if (rule.IgnoreCollectionOrder)
                options.Add("ignore order");

            if (rule.IgnoreCase)
                options.Add("ignore case");

            if (options.Any())
            {
                description += $" ({string.Join(", ", options)})";
            }
        }

        return description;
    }

    private async Task RunComparison()
    {
        if (!CanRunComparison)
            return;

        IsComparing = true;
        ComparisonResult = null;
        DifferenceSummary = null;
        ShowAllDifferences = false;

        try
        {
            // Update configuration
            ComparisonService.SetIgnoreCollectionOrder(IgnoreCollectionOrder);
            ComparisonService.SetIgnoreStringCase(IgnoreStringCase);

            // Apply all ignore rules
            foreach (var rule in IgnoreRules)
            {
                rule.ApplyTo(ComparisonService.GetCurrentConfig());
            }

            // Run comparison
            OldFileContent.Position = 0;
            NewFileContent.Position = 0;
            ComparisonResult = await ComparisonService.CompareXmlFilesAsync(
                OldFileContent,
                NewFileContent,
                SelectedModelName);

            // Generate enhanced summary
            var categorizer = new DifferenceCategorizer();
            DifferenceSummary = categorizer.CategorizeAndSummarize(ComparisonResult);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error comparing files: {ex.Message}");
            Console.WriteLine($"Error running comparison: {ex.Message}");
        }
        finally
        {
            IsComparing = false;
            StateHasChanged();
        }
    }

    private IEnumerable<Difference> GetFilteredDifferences()
    {
        if (ComparisonResult == null || ComparisonResult.Differences.Count == 0)
            return Enumerable.Empty<Difference>();

        return ShowAllDifferences
            ? ComparisonResult.Differences
            : ComparisonResult.Differences.Take(100);
    }

    private void ToggleShowAllDifferences()
    {
        ShowAllDifferences = !ShowAllDifferences;
    }

    private string FormatValue(object value)
    {
        if (value == null)
            return "null";

        if (value is DateTime dt)
            return dt.ToString("yyyy-MM-dd HH:mm:ss");

        if (value is string str && str.Length > 100)
            return str.Substring(0, 97) + "...";

        return value.ToString();
    }

    private async Task ExportResults()
    {
        if (DifferenceSummary == null)
            return;

        var report = DifferenceSummary.GenerateReport();

        // In a real app, you would use JSInterop to download the file
        await JSRuntime.InvokeVoidAsync(
            "saveAsFile",
            "comparison-report.md",
            "text/markdown",
            report);
    }

    private async Task HandleFolder1Upload(InputFileChangeEventArgs e)
    {
        try
        {
            foreach (var file in e.GetMultipleFiles(20)) // Allow up to 20 files
            {
                var stream = new MemoryStream();
                await file.OpenReadStream(maxAllowedSize: 10485760).CopyToAsync(stream);
                stream.Position = 0;

                Folder1Files.Add((stream, file.Name));
            }

            // Sort files by name to help with matching
            Folder1Files = Folder1Files.OrderBy(f => f.FileName).ToList();

            // Force UI refresh
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading Folder 1 files: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("alert", $"Error loading files: {ex.Message}");
            StateHasChanged();
        }
    }

    private async Task HandleFolder2Upload(InputFileChangeEventArgs e)
    {
        try
        {
            foreach (var file in e.GetMultipleFiles(20)) // Allow up to 20 files
            {
                var stream = new MemoryStream();
                await file.OpenReadStream(maxAllowedSize: 10485760).CopyToAsync(stream);
                stream.Position = 0;

                Folder2Files.Add((stream, file.Name));
            }

            // Sort files by name to help with matching
            Folder2Files = Folder2Files.OrderBy(f => f.FileName).ToList();

            // Force UI refresh
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading Folder 2 files: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("alert", $"Error loading files: {ex.Message}");
            StateHasChanged();
        }
    }

    // Methods to remove files from folders
    private void RemoveFolder1File(int index)
    {
        if (index >= 0 && index < Folder1Files.Count)
        {
            Folder1Files.RemoveAt(index);
        }
    }

    private void RemoveFolder2File(int index)
    {
        if (index >= 0 && index < Folder2Files.Count)
        {
            Folder2Files.RemoveAt(index);
        }
    }

    // Run comparison between the two folders
    private async Task RunFolderComparison()
    {
        if (Folder1Files.Count == 0 || Folder2Files.Count == 0)
            return;

        IsComparing = true;
        FolderComparisonResult = null;
        SelectedPairIndex = -1;

        try
        {
            // Update configuration
            ComparisonService.SetIgnoreCollectionOrder(IgnoreCollectionOrder);
            ComparisonService.SetIgnoreStringCase(IgnoreStringCase);

            // Apply all ignore rules
            foreach (var rule in IgnoreRules)
            {
                rule.ApplyTo(ComparisonService.GetCurrentConfig());
            }

            // Convert our in-memory lists to the format needed by the service
            var folder1FilesList = Folder1Files
                .Select(f => ((Stream)f.Stream, f.FileName))
                .ToList();

            var folder2FilesList = Folder2Files
                .Select(f => ((Stream)f.Stream, f.FileName))
                .ToList();

            // Run folder comparison
            FolderComparisonResult = await ComparisonService.CompareFoldersAsync(
                folder1FilesList,
                folder2FilesList,
                SelectedModelName);

            // Select the first file pair by default if there are differences
            if (!FolderComparisonResult.AllEqual && FolderComparisonResult.FilePairResults.Count > 0)
            {
                SelectedPairIndex = 0;
                var selectedPair = FolderComparisonResult.FilePairResults[0];
                ComparisonResult = selectedPair.Result;
                DifferenceSummary = selectedPair.Summary;
            }

            if (!FolderComparisonResult.AllEqual && FolderComparisonResult.FilePairResults.Count > 1 && EnablePatternAnalysis)
            {
                // Auto-generate pattern analysis if we have multiple files with differences
                GeneratePatternAnalysis();
            }
            else
            {
                // Reset pattern analysis if no differences or only one file
                PatternAnalysis = null;
                ShowPatternSummary = false;
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error comparing files: {ex.Message}");
            Console.WriteLine($"Error running comparison: {ex.Message}");
        }
        finally
        {
            IsComparing = false;
            StateHasChanged();
        }
    }

    // Method to select a specific comparison result to view
    private void SelectPairResult(int index)
    {
        if (index >= 0 && index < FolderComparisonResult?.FilePairResults.Count)
        {
            SelectedPairIndex = index;

            // Set the current ComparisonResult and DifferenceSummary for display
            var selectedPair = FolderComparisonResult.FilePairResults[index];
            ComparisonResult = selectedPair.Result;
            DifferenceSummary = selectedPair.Summary;
        }
    }

    // Define a helper property for the UI
    private bool CanRunFolderComparison =>
        !string.IsNullOrEmpty(SelectedModelName) &&
        Folder1Files.Count > 0 &&
        Folder2Files.Count > 0;

    // Export methods for folder comparison
    private async Task ExportFolderResults()
    {
        if (FolderComparisonResult == null || SelectedPairIndex < 0)
            return;

        var selectedPair = FolderComparisonResult.FilePairResults[SelectedPairIndex];
        var file1Name = Path.GetFileNameWithoutExtension(selectedPair.File1Name);
        var file2Name = Path.GetFileNameWithoutExtension(selectedPair.File2Name);

        var report = selectedPair.Summary.GenerateReport();

        // Add a header to clarify which files were compared
        var headerReport = $"# Comparison Report\n\n" +
                          $"V1 file: **{selectedPair.File1Name}**\n\n" +
                          $"V2 file: **{selectedPair.File2Name}**\n\n" +
                          $"---\n\n" +
                          report;

        // In a real app, you would use JSInterop to download the file
        await JSRuntime.InvokeVoidAsync(
            "saveAsFile",
            $"comparison-{file1Name}-vs-{file2Name}.md",
            "text/markdown",
            headerReport);
    }

    // Export a summary of all folder comparisons
    private async Task ExportAllFolderResults()
    {
        if (FolderComparisonResult == null || FolderComparisonResult.FilePairResults.Count == 0)
            return;

        var sb = new StringBuilder();

        sb.AppendLine("# V1 vs V2 Folder Comparison Report");
        sb.AppendLine();
        sb.AppendLine($"Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine();

        sb.AppendLine("## Summary");
        sb.AppendLine();
        sb.AppendLine("| V1 File | V2 File | Status | Differences |");
        sb.AppendLine("|---------|---------|--------|------------|");

        foreach (var result in FolderComparisonResult.FilePairResults)
        {
            var status = result.AreEqual ? "✓ Equal" : "❌ Different";
            var diffCount = result.AreEqual ? "0" : result.Summary.TotalDifferenceCount.ToString();

            sb.AppendLine($"| {result.File1Name} | {result.File2Name} | {status} | {diffCount} |");
        }

        sb.AppendLine();

        // Add detailed comparison for each file pair
        for (int i = 0; i < FolderComparisonResult.FilePairResults.Count; i++)
        {
            var result = FolderComparisonResult.FilePairResults[i];

            sb.AppendLine($"## Pair {i + 1}: {result.File1Name} vs {result.File2Name}");
            sb.AppendLine();

            if (result.AreEqual)
            {
                sb.AppendLine("**No differences found.** The objects are identical according to current comparison rules.");
            }
            else
            {
                // Include only the most important parts of the report for each file
                sb.AppendLine($"**Total Differences: {result.Summary.TotalDifferenceCount}**");
                sb.AppendLine();

                // Add top differences by category
                sb.AppendLine("### Differences by Category");
                sb.AppendLine();
                sb.AppendLine("| Category | Count | Percentage |");
                sb.AppendLine("|----------|-------|------------|");

                foreach (var category in result.Summary.DifferencesByChangeType.OrderByDescending(c => c.Value.Count).Take(5))
                {
                    sb.AppendLine($"| {FormatCategoryName(category.Key)} | {category.Value.Count} | {result.Summary.CategoryPercentages[category.Key]}% |");
                }

                sb.AppendLine();

                // Add a sample of actual differences
                sb.AppendLine("### Sample Differences");
                sb.AppendLine();

                var sampleDiffs = result.Result.Differences.Take(10).ToList();
                foreach (var diff in sampleDiffs)
                {
                    sb.AppendLine($"- Property: `{diff.PropertyName}`");
                    sb.AppendLine($"  - V1: `{FormatValue(diff.Object1Value)}`");
                    sb.AppendLine($"  - V2: `{FormatValue(diff.Object2Value)}`");
                    sb.AppendLine();
                }

                if (result.Result.Differences.Count > 10)
                {
                    sb.AppendLine($"*...and {result.Result.Differences.Count - 10} more differences*");
                    sb.AppendLine();
                }
            }

            sb.AppendLine("---");
            sb.AppendLine();
        }

        await JSRuntime.InvokeVoidAsync(
            "saveAsFile",
            "folder-comparison-report.md",
            "text/markdown",
            sb.ToString());
    }

    public string GeneratePatternAnalysisReport(ComparisonPatternAnalysis analysis)
    {
        var sb = new StringBuilder();

        sb.AppendLine("# XML Comparison Pattern Analysis");
        sb.AppendLine();
        sb.AppendLine("## Summary");
        sb.AppendLine();
        sb.AppendLine($"- **Total Files Compared:** {analysis.TotalFilesPaired} pairs");
        sb.AppendLine($"- **Files With Differences:** {analysis.FilesWithDifferences} pairs");
        sb.AppendLine($"- **Total Differences Found:** {analysis.TotalDifferences}");
        sb.AppendLine();

        // Category breakdown
        sb.AppendLine("## Differences by Category");
        sb.AppendLine();
        sb.AppendLine("| Category | Count | Percentage |");
        sb.AppendLine("|----------|-------|------------|");

        foreach (var category in analysis.TotalByCategory.OrderByDescending(c => c.Value))
        {
            if (category.Value > 0)
            {
                double percentage = (double)category.Value / analysis.TotalDifferences * 100;
                sb.AppendLine($"| {FormatCategoryName(category.Key)} | {category.Value} | {percentage:F1}% |");
            }
        }
        sb.AppendLine();

        // Common patterns across files
        sb.AppendLine("## Common Difference Patterns");
        sb.AppendLine();
        sb.AppendLine("The following property paths showed differences in multiple files:");
        sb.AppendLine();
        sb.AppendLine("| Property Path | Files Affected | Total Occurrences |");
        sb.AppendLine("|--------------|----------------|-------------------|");

        foreach (var pattern in analysis.CommonPathPatterns)
        {
            sb.AppendLine($"| `{pattern.PatternPath}` | {pattern.FileCount} | {pattern.OccurrenceCount} |");
        }
        sb.AppendLine();

        // Common value changes
        sb.AppendLine("## Common Property Value Changes");
        sb.AppendLine();
        sb.AppendLine("The following specific property value changes appeared in multiple files:");
        sb.AppendLine();

        foreach (var change in analysis.CommonPropertyChanges.Take(10))
        {
            sb.AppendLine($"### `{change.PropertyName}`");
            sb.AppendLine();
            sb.AppendLine($"Changed in {change.AffectedFiles.Count} files, {change.OccurrenceCount} total occurrences");
            sb.AppendLine();

            foreach (var valueChange in change.CommonChanges)
            {
                sb.AppendLine($"- From: `{TruncateValue(valueChange.Key, 50)}` → To: `{TruncateValue(valueChange.Value, 50)}`");
            }
            sb.AppendLine();
            sb.AppendLine("Affected files:");
            sb.AppendLine();
            foreach (var file in change.AffectedFiles.Take(5))
            {
                sb.AppendLine($"- {file}");
            }

            if (change.AffectedFiles.Count > 5)
            {
                sb.AppendLine($"- ...and {change.AffectedFiles.Count - 5} more");
            }

            sb.AppendLine();
        }

        // File groups
        if (analysis.SimilarFileGroups.Count > 0)
        {
            sb.AppendLine("## File Similarity Groups");
            sb.AppendLine();
            sb.AppendLine("Files with similar difference patterns have been grouped:");
            sb.AppendLine();

            foreach (var group in analysis.SimilarFileGroups.OrderByDescending(g => g.FileCount))
            {
                sb.AppendLine($"### {group.GroupName} ({group.FileCount} files)");
                sb.AppendLine();
                sb.AppendLine($"**Pattern:** {group.CommonPattern}");
                sb.AppendLine();
                sb.AppendLine("Files in this group:");
                sb.AppendLine();

                foreach (var file in group.FilePairs)
                {
                    sb.AppendLine($"- {file}");
                }

                sb.AppendLine();
            }
        }

        return sb.ToString();
    }

    private string FormatCategoryName(DifferenceCategory category)
    {
        switch (category)
        {
            case DifferenceCategory.TextContentChanged:
                return "Text Content Changed";
            case DifferenceCategory.NumericValueChanged:
                return "Numeric Value Changed";
            case DifferenceCategory.DateTimeChanged:
                return "Date/Time Changed";
            case DifferenceCategory.BooleanValueChanged:
                return "Boolean Value Changed";
            case DifferenceCategory.CollectionItemChanged:
                return "Collection Item Changed";
            case DifferenceCategory.ItemAdded:
                return "Item Added";
            case DifferenceCategory.ItemRemoved:
                return "Item Removed";
            case DifferenceCategory.NullValueChange:
                return "Null Value Change";
            default:
                return "Other";
        }
    }

    private string TruncateValue(string value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "null";
        return value.Length <= maxLength ? value : value.Substring(0, maxLength - 3) + "...";
    }

    public ComparisonPatternAnalysis AnalyzePatterns(MultiFolderComparisonResult folderResult)
    {
        var analysis = new ComparisonPatternAnalysis
            {
                TotalFilesPaired = folderResult.TotalPairsCompared,
                FilesWithDifferences = folderResult.FilePairResults.Count(r => !r.AreEqual),
                TotalDifferences = folderResult.FilePairResults.Sum(r => r.Summary?.TotalDifferenceCount ?? 0)
            };

        // Initialize category counts
        foreach (DifferenceCategory category in Enum.GetValues(typeof(DifferenceCategory)))
        {
            analysis.TotalByCategory[category] = 0;
        }

        // Process all differences to find common patterns
        var allPathPatterns = new Dictionary<string, GlobalPatternInfo>();
        var allPropertyChanges = new Dictionary<string, GlobalPropertyChangeInfo>();

        foreach (var filePair in folderResult.FilePairResults)
        {
            if (filePair.AreEqual) continue;

            var pairIdentifier = $"{filePair.File1Name} vs {filePair.File2Name}";

            // Add to category counts
            foreach (var category in filePair.Summary.DifferencesByChangeType)
            {
                if (analysis.TotalByCategory.ContainsKey(category.Key))
                {
                    analysis.TotalByCategory[category.Key] += category.Value.Count;
                }
            }

            // Process each difference
            foreach (var diff in filePair.Result.Differences)
            {
                // Normalize the property path (remove indices, backing fields)
                string normalizedPath = NormalizePropertyPath(diff.PropertyName);

                // Create pattern info if not exists
                if (!allPathPatterns.ContainsKey(normalizedPath))
                {
                    allPathPatterns[normalizedPath] = new GlobalPatternInfo
                        {
                            PatternPath = normalizedPath,
                            OccurrenceCount = 0,
                            FileCount = 0
                        };
                }

                // Update pattern info
                var patternInfo = allPathPatterns[normalizedPath];
                patternInfo.OccurrenceCount++;
                if (!patternInfo.AffectedFiles.Contains(pairIdentifier))
                {
                    patternInfo.AffectedFiles.Add(pairIdentifier);
                    patternInfo.FileCount++;
                }

                // Add example if we don't have many
                if (patternInfo.Examples.Count < 3)
                {
                    patternInfo.Examples.Add(diff);
                }

                // Track property change info (create key from property + old value + new value)
                var oldValue = diff.Object1Value?.ToString() ?? "null";
                var newValue = diff.Object2Value?.ToString() ?? "null";
                var changeKey = $"{normalizedPath}|{oldValue}|{newValue}";

                if (!allPropertyChanges.ContainsKey(changeKey))
                {
                    allPropertyChanges[changeKey] = new GlobalPropertyChangeInfo
                        {
                            PropertyName = normalizedPath,
                            OccurrenceCount = 0,
                            CommonChanges = new Dictionary<string, string>
                    {
                        { oldValue, newValue }
                    }
                        };
                }

                // Update property change info
                var changeInfo = allPropertyChanges[changeKey];
                changeInfo.OccurrenceCount++;
                if (!changeInfo.AffectedFiles.Contains(pairIdentifier))
                {
                    changeInfo.AffectedFiles.Add(pairIdentifier);
                }
            }
        }

        // Sort and select most common patterns
        analysis.CommonPathPatterns = allPathPatterns.Values
            .Where(p => p.FileCount > 1) // Only patterns that appear in multiple files
            .OrderByDescending(p => p.FileCount)
            .ThenByDescending(p => p.OccurrenceCount)
            .Take(20) // Limit to top 20 patterns
            .ToList();

        // Sort and select most common property changes
        analysis.CommonPropertyChanges = allPropertyChanges.Values
            .Where(c => c.AffectedFiles.Count > 1) // Only changes that appear in multiple files
            .OrderByDescending(c => c.AffectedFiles.Count)
            .ThenByDescending(c => c.OccurrenceCount)
            .Take(20) // Limit to top 20 common changes
            .ToList();

        // Group similar files based on their difference patterns
        GroupSimilarFiles(folderResult, analysis);

        return analysis;
    }

    private string NormalizePropertyPath(string propertyPath)
    {
        // Replace array indices with [*]
        var normalized = System.Text.RegularExpressions.Regex.Replace(propertyPath, @"\[\d+\]", "[*]");

        // Remove backing fields
        normalized = System.Text.RegularExpressions.Regex.Replace(normalized, @"<(\w+)>k__BackingField", "$1");

        return normalized;
    }

    // Group similar files based on their difference patterns
    private void GroupSimilarFiles(MultiFolderComparisonResult folderResult, ComparisonPatternAnalysis analysis)
    {
        // Skip if not enough files with differences
        if (analysis.FilesWithDifferences <= 1)
            return;

        // Create fingerprints of each file's differences
        var fileFingerprints = new Dictionary<string, HashSet<string>>();

        foreach (var filePair in folderResult.FilePairResults)
        {
            if (filePair.AreEqual) continue;

            var pairIdentifier = $"{filePair.File1Name} vs {filePair.File2Name}";
            var fingerprint = new HashSet<string>();

            foreach (var diff in filePair.Result.Differences)
            {
                fingerprint.Add(NormalizePropertyPath(diff.PropertyName));
            }

            fileFingerprints[pairIdentifier] = fingerprint;
        }

        // Build similarity matrix
        var similarities = new Dictionary<(string, string), double>();
        var fileIds = fileFingerprints.Keys.ToList();

        for (int i = 0; i < fileIds.Count; i++)
        {
            for (int j = i + 1; j < fileIds.Count; j++)
            {
                var file1 = fileIds[i];
                var file2 = fileIds[j];
                var set1 = fileFingerprints[file1];
                var set2 = fileFingerprints[file2];

                // Calculate Jaccard similarity
                var intersection = set1.Intersect(set2).Count();
                var union = set1.Count + set2.Count - intersection;
                var similarity = (double)intersection / (union == 0 ? 1 : union);

                similarities[(file1, file2)] = similarity;
            }
        }

        // Group files using a simple threshold-based approach
        var grouped = new HashSet<string>();
        var similarityThreshold = 0.6; // 60% similarity to be considered in the same group

        foreach (var similarity in similarities.OrderByDescending(s => s.Value))
        {
            if (similarity.Value < similarityThreshold)
                continue;

            var file1 = similarity.Key.Item1;
            var file2 = similarity.Key.Item2;

            // Find or create a group
            var existingGroup = analysis.SimilarFileGroups.FirstOrDefault(g =>
                g.FilePairs.Contains(file1) || g.FilePairs.Contains(file2));

            if (existingGroup != null)
            {
                // Add to existing group
                if (!existingGroup.FilePairs.Contains(file1))
                {
                    existingGroup.FilePairs.Add(file1);
                    existingGroup.FileCount++;
                    grouped.Add(file1);
                }

                if (!existingGroup.FilePairs.Contains(file2))
                {
                    existingGroup.FilePairs.Add(file2);
                    existingGroup.FileCount++;
                    grouped.Add(file2);
                }
            }
            else
            {
                // Create new group
                var newGroup = new SimilarFileGroup
                    {
                        GroupName = $"Group {analysis.SimilarFileGroups.Count + 1}",
                        FileCount = 0,
                        FilePairs = new List<string>(),
                        CommonPattern = "Files with similar difference patterns"
                    };

                if (!grouped.Contains(file1))
                {
                    newGroup.FilePairs.Add(file1);
                    newGroup.FileCount++;
                    grouped.Add(file1);
                }

                if (!grouped.Contains(file2))
                {
                    newGroup.FilePairs.Add(file2);
                    newGroup.FileCount++;
                    grouped.Add(file2);
                }

                if (newGroup.FileCount > 0)
                {
                    analysis.SimilarFileGroups.Add(newGroup);
                }
            }
        }

        // For each group, identify common patterns
        foreach (var group in analysis.SimilarFileGroups)
        {
            // Find patterns common to all files in the group
            HashSet<string> commonPatterns = null;

            foreach (var file in group.FilePairs)
            {
                var filePatterns = fileFingerprints[file];

                if (commonPatterns == null)
                {
                    commonPatterns = new HashSet<string>(filePatterns);
                }
                else
                {
                    commonPatterns.IntersectWith(filePatterns);
                }
            }

            if (commonPatterns != null && commonPatterns.Count > 0)
            {
                group.CommonPattern = $"{commonPatterns.Count} common difference pattern(s) including: " +
                    string.Join(", ", commonPatterns.Take(3).Select(p => $"'{p}'"));
            }
        }

        // Add singleton groups for any files not grouped
        foreach (var file in fileFingerprints.Keys)
        {
            if (!grouped.Contains(file))
            {
                analysis.SimilarFileGroups.Add(new SimilarFileGroup
                    {
                        GroupName = $"Group {analysis.SimilarFileGroups.Count + 1}",
                        FileCount = 1,
                        FilePairs = new List<string> { file },
                        CommonPattern = "Unique difference pattern"
                    });
            }
        }
    }

    private void GeneratePatternAnalysis()
    {
        if (FolderComparisonResult == null || FolderComparisonResult.FilePairResults.Count <= 1)
            return;

        // Create a new pattern analyzer
        PatternAnalysis = AnalyzePatterns(FolderComparisonResult);
        ShowPatternSummary = true;
    }

    // Export pattern analysis report
    private async Task ExportPatternAnalysisReport(string filename)
    {
        if (PatternAnalysis == null)
            return;

        var report = GeneratePatternAnalysisReport(PatternAnalysis);

        await JSRuntime.InvokeVoidAsync(
            "saveAsFile",
            filename,
            "text/markdown",
            report);
    }
}
@namespace ComparisonTool.Web.Components.Comparison
@using ComparisonTool.Core
@using ComparisonTool.Core.Comparison.Configuration
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using Microsoft.JSInterop
@using MudBlazor

@inject IComparisonConfigurationService ConfigService
@inject IJSRuntime JSRuntime

<MudPaper Elevation="2" Class="pa-4">
    <MudStack Spacing="3">
        <MudText Typo="Typo.h6">Step 2: Configure Comparison Options</MudText>
        
        <!-- Global Settings -->
        <MudStack Spacing="2">
            <MudText Typo="Typo.subtitle2">Global Settings</MudText>
            <MudSwitch T="bool"
                       Value="IgnoreCollectionOrder"
                       ValueChanged="@((bool val) => { IgnoreCollectionOrder = val; OnIgnoreCollectionOrderChanged.InvokeAsync(val); })"
                       Color="Color.Primary"
                       Label="Ignore Collection Order Globally"
                       aria-label="Ignore collection order globally" />
            <MudSwitch T="bool"
                       Value="IgnoreStringCase"
                       ValueChanged="@((bool val) => { IgnoreStringCase = val; OnIgnoreStringCaseChanged.InvokeAsync(val); })"
                       Color="Color.Primary"
                       Label="Ignore String Case Globally"
                       aria-label="Ignore string case globally" />
            <MudSwitch T="bool"
                       Value="IgnoreTrailingWhitespaceAtEnd"
                       ValueChanged="@((bool val) => { IgnoreTrailingWhitespaceAtEnd = val; OnIgnoreTrailingWhitespaceAtEndChanged.InvokeAsync(val); })"
                       Color="Color.Primary"
                       Label="Ignore Trailing Spaces/Tabs at End of Strings"
                       aria-label="Ignore trailing spaces/tabs at end of strings" />
            <MudSwitch T="bool"
                       Value="IgnoreXmlNamespaces"
                       ValueChanged="@((bool val) => { IgnoreXmlNamespaces = val; OnIgnoreXmlNamespacesChanged.InvokeAsync(val); })"
                       Color="Color.Primary"
                       Label="Ignore XML Namespaces (Lenient Mode)"
                       aria-label="Ignore XML namespaces (lenient mode)" />
        </MudStack>

        <MudDivider />

        <!-- Analysis Options -->
        <MudStack Spacing="2">
            <MudText Typo="Typo.subtitle2">Analysis Options</MudText>
            <MudSwitch T="bool"
                       Value="EnableSemanticAnalysis"
                       ValueChanged="@((bool val) => { EnableSemanticAnalysis = val; OnEnableSemanticAnalysisChanged.InvokeAsync(val); })"
                       Color="Color.Primary"
                       Label="Enable Semantic Analysis"
                       aria-label="Enable semantic analysis" />
            <MudSwitch T="bool"
                       Value="EnableEnhancedStructuralAnalysis"
                       ValueChanged="@((bool val) => { EnableEnhancedStructuralAnalysis = val; OnEnableEnhancedStructuralAnalysisChanged.InvokeAsync(val); })"
                       Color="Color.Primary"
                       Label="Enable Enhanced Structural Pattern Analysis"
                       aria-label="Enable enhanced structural pattern analysis" />
        </MudStack>

        <MudDivider />

        <!-- Smart Ignore Rules Section -->
        <MudStack Spacing="2">
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Typo="Typo.subtitle2">Smart Ignore Rules</MudText>
                    @{
                        var smartRulesCount = GetSmartIgnoreRules().Count;
                    }
                    @if (smartRulesCount > 0)
                    {
                        <MudChip T="string" Size="Size.Small" Color="Color.Default">@smartRulesCount active</MudChip>
                    }
                </MudStack>
                <MudButton Variant="Variant.Outlined" 
                           Size="Size.Small"
                           OnClick="@(() => IsSmartIgnoreCollapsed = !IsSmartIgnoreCollapsed)"
                           EndIcon="@(IsSmartIgnoreCollapsed ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ExpandLess)">
                    @(IsSmartIgnoreCollapsed ? "Show" : "Hide")
                </MudButton>
            </MudStack>
            
            @if (!IsSmartIgnoreCollapsed)
            {
                <SmartIgnoreConfigurationPanel SmartIgnoreRules="@GetSmartIgnoreRules()"
                                               OnRuleAdded="@HandleSmartIgnoreRuleAdded"
                                               OnRuleRemoved="@HandleSmartIgnoreRuleRemoved"
                                               OnPresetApplied="@HandleSmartIgnorePresetApplied"
                                               OnRulesCleared="@HandleSmartIgnoreRulesCleared" />
            }
        </MudStack>

        <MudDivider />

        <!-- Tree Navigator -->
        <MudStack Spacing="2">
            <MudText Typo="Typo.subtitle2">Tree Navigator (Visual Property Selection)</MudText>
            <MudStack Row="true" Spacing="2">
                <MudButton Variant="Variant.Outlined" 
                           Size="Size.Small"
                           StartIcon="@Icons.Material.Filled.List"
                           OnClick="OpenPropertySelector" 
                           Disabled="@(!IsModelSelected)"
                           aria-label="Open simple property selector">
                    Simple Property Selector
                </MudButton>
                <MudButton Variant="Variant.Outlined" 
                           Size="Size.Small"
                           Color="Color.Success"
                           StartIcon="@Icons.Material.Filled.AccountTree"
                           OnClick="OpenTreePropertySelector" 
                           Disabled="@(!IsModelSelected)"
                           aria-label="Open tree navigator">
                    Tree Navigator ⭐
                </MudButton>
            </MudStack>
            @if (!IsModelSelected)
            {
                <MudText Typo="Typo.caption" Color="Color.Default">
                    Select a model first to browse and ignore properties.
                </MudText>
            }
        </MudStack>

        <!-- Ignore Rules List -->
        @if (IgnoreRules.Any())
        {
            <MudStack Spacing="2">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        <MudIcon Icon="@Icons.Material.Filled.Block" Size="Size.Small" />
                        <MudText Typo="Typo.subtitle2">@IgnoreRules.Count Ignore Rules</MudText>
                    </MudStack>
                    <MudButton Variant="Variant.Outlined" 
                               Size="Size.Small"
                               Color="Color.Error"
                               StartIcon="@Icons.Material.Filled.DeleteSweep"
                               OnClick="HandleClearAllIgnoreRules"
                               aria-label="Clear all ignore rules">
                        Clear All
                    </MudButton>
                </MudStack>
                
                <MudPaper Outlined="true" Style="max-height: 300px; overflow-y: auto;">
                    @{
                        var groupedRules = GetCompactRuleGroups();
                    }
                    
                    @foreach (var group in groupedRules)
                    {
                        @if (groupedRules.Count > 1)
                        {
                            <MudStack Row="true" Class="pa-2 mud-background-gray" AlignItems="AlignItems.Center" Spacing="1">
                                <MudIcon Icon="@GetGroupIcon(group.Name)" Size="Size.Small" />
                                <MudText Typo="Typo.caption">@group.Name (@group.Rules.Count)</MudText>
                            </MudStack>
                        }
                        
                        @foreach (var rule in group.Rules)
                        {
                            <MudStack Row="true" Class="pa-2" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                <MudText Typo="Typo.body2" Style="font-family: 'Consolas', 'Monaco', monospace; word-break: break-all;">
                                    @rule.PropertyPath
                                </MudText>
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                    @if (rule.IgnoreCompletely)
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Error" Icon="@Icons.Material.Filled.VisibilityOff">
                                            Ignore
                                        </MudChip>
                                    }
                                    @if (rule.IgnoreCollectionOrder)
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Warning" Icon="@Icons.Material.Filled.SwapVert">
                                            Order
                                        </MudChip>
                                    }
                                    <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                   Size="Size.Small"
                                                   Color="Color.Error"
                                                   OnClick="@(() => OnIgnoreRuleRemoved.InvokeAsync(rule))"
                                                   aria-label="Remove rule" />
                                </MudStack>
                            </MudStack>
                            <MudDivider />
                        }
                    }
                </MudPaper>
            </MudStack>
        }
        else
        {
            <MudPaper Outlined="true" Class="pa-4" Style="text-align: center;">
                <MudStack Row="true" Justify="Justify.Center" AlignItems="AlignItems.Center" Spacing="2">
                    <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Default" />
                    <MudText Typo="Typo.body2" Color="Color.Default">No ignore rules configured</MudText>
                </MudStack>
            </MudPaper>
        }
        
        <MudDivider />

        <!-- Import/Export Buttons -->
        <MudStack Row="true" Spacing="2">
            <InputFile OnChange="HandleImportFileSelected" accept=".json" id="import-config-input" style="display: none;" />
            <MudButton Variant="Variant.Outlined" 
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Upload"
                       OnClick="@(() => { })"
                       HtmlTag="label"
                       for="import-config-input"
                       aria-label="Import configuration">
                Import Config...
            </MudButton>
            <MudButton Variant="Variant.Outlined" 
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Download"
                       OnClick="ExportConfiguration" 
                       Disabled="@(!IgnoreRules.Any())"
                       aria-label="Export configuration">
                Export Config
            </MudButton>
        </MudStack>
        
        @if (!string.IsNullOrEmpty(importStatusMessage))
        {
            <MudAlert Severity="@(importStatusIsError ? Severity.Error : Severity.Success)" Variant="Variant.Outlined">
                @importStatusMessage
            </MudAlert>
        }

        <!-- Run Comparison Button -->
        <MudButton Variant="Variant.Filled" 
                   Color="Color.Success" 
                   FullWidth="true"
                   StartIcon="@Icons.Material.Filled.PlayArrow"
                   OnClick="OnRunComparison" 
                   Disabled="@(!CanRunComparison)"
                   aria-label="Run comparison">
            Run Comparison
        </MudButton>
    </MudStack>
</MudPaper>

@code {
    [Parameter] public bool IgnoreCollectionOrder { get; set; }
    [Parameter] public EventCallback<bool> OnIgnoreCollectionOrderChanged { get; set; }
    [Parameter] public bool IgnoreStringCase { get; set; } 
    [Parameter] public EventCallback<bool> OnIgnoreStringCaseChanged { get; set; }
    [Parameter] public bool IgnoreTrailingWhitespaceAtEnd { get; set; }
    [Parameter] public EventCallback<bool> OnIgnoreTrailingWhitespaceAtEndChanged { get; set; }
    [Parameter] public bool IgnoreXmlNamespaces { get; set; }
    [Parameter] public EventCallback<bool> OnIgnoreXmlNamespacesChanged { get; set; }
    [Parameter] public bool EnableSemanticAnalysis { get; set; }
    [Parameter] public EventCallback<bool> OnEnableSemanticAnalysisChanged { get; set; }
    [Parameter] public bool EnableEnhancedStructuralAnalysis { get; set; }
    [Parameter] public EventCallback<bool> OnEnableEnhancedStructuralAnalysisChanged { get; set; }
    [Parameter] public List<IgnoreRule> IgnoreRules { get; set; } = new List<IgnoreRule>();
    [Parameter] public EventCallback<IgnoreRule> OnIgnoreRuleAdded { get; set; }
    [Parameter] public EventCallback<IgnoreRule> OnIgnoreRuleRemoved { get; set; }
    [Parameter] public EventCallback OnIgnoreRulesCleared { get; set; }
    [Parameter] public Type ModelType { get; set; }
    [Parameter] public EventCallback OnPropertySelectorOpened { get; set; }
    [Parameter] public EventCallback OnTreePropertySelectorOpened { get; set; }
    [Parameter] public EventCallback OnRunComparison { get; set; }
    [Parameter] public bool CanRunComparison { get; set; }

    private bool IsModelSelected => ModelType != null;
    private string importStatusMessage = string.Empty;
    private bool importStatusIsError = false;
    private bool IsSmartIgnoreCollapsed = true; // Start collapsed to reduce visual noise

    private async Task OpenPropertySelector()
    {
        await OnPropertySelectorOpened.InvokeAsync();
    }

    private async Task OpenTreePropertySelector()
    {
        await OnTreePropertySelectorOpened.InvokeAsync();
    }

    // Smart Ignore Rules handling
    private List<SmartIgnoreRule> GetSmartIgnoreRules()
    {
        return ConfigService.GetSmartIgnoreRules().ToList();
    }

    private async Task HandleSmartIgnoreRuleAdded(SmartIgnoreRule rule)
    {
        ConfigService.AddSmartIgnoreRule(rule);
        StateHasChanged();
    }

    private async Task HandleSmartIgnoreRuleRemoved(SmartIgnoreRule rule)
    {
        ConfigService.RemoveSmartIgnoreRule(rule);
        StateHasChanged();
    }

    private async Task HandleSmartIgnorePresetApplied(string presetName)
    {
        ConfigService.ApplySmartIgnorePreset(presetName);
        StateHasChanged();
    }

    private async Task HandleSmartIgnoreRulesCleared()
    {
        ConfigService.ClearSmartIgnoreRules();
        StateHasChanged();
    }

    private async Task HandleClearAllIgnoreRules()
    {
        ConfigService.ClearIgnoreRules();
        await OnIgnoreRulesCleared.InvokeAsync();
        StateHasChanged();
    }

    private string GetRuleDescription(IgnoreRule rule)
    {
        var parts = new List<string>();
        if (rule.IgnoreCompletely) parts.Add("Ignore Completely");
        if (rule.IgnoreCollectionOrder) parts.Add("Ignore Order");
        return string.Join(", ", parts);
    }

    // Helper classes and methods for compact UI
    private class CompactRuleGroup
    {
        public string Name { get; set; }
        public string Icon { get; set; }
        public List<IgnoreRule> Rules { get; set; } = new();
    }

    private string GetGroupIcon(string groupName)
    {
        return groupName switch
        {
            "Root Properties" => Icons.Material.Filled.Home,
            "Nested Properties" => Icons.Material.Filled.AccountTree,
            "Collections" => Icons.Material.Filled.List,
            _ => Icons.Material.Filled.Rule
        };
    }

    private List<CompactRuleGroup> GetCompactRuleGroups()
    {
        var groups = new List<CompactRuleGroup>();

        // Simple Properties (single level)
        var simpleRules = IgnoreRules.Where(r => !r.PropertyPath.Contains('.') && !r.PropertyPath.Contains('['))
                                   .OrderBy(r => r.PropertyPath)
                                   .ToList();
        if (simpleRules.Any())
        {
            groups.Add(new CompactRuleGroup
            {
                Name = "Root Properties",
                Icon = Icons.Material.Filled.Home,
                Rules = simpleRules
            });
        }

        // Nested Properties (multiple levels but not collections)
        var nestedRules = IgnoreRules.Where(r => r.PropertyPath.Contains('.') && 
                                               !r.PropertyPath.Contains('[') && 
                                               !r.PropertyPath.Contains(']'))
                                    .OrderBy(r => r.PropertyPath)
                                    .ToList();
        if (nestedRules.Any())
        {
            groups.Add(new CompactRuleGroup
            {
                Name = "Nested Properties",
                Icon = Icons.Material.Filled.AccountTree,
                Rules = nestedRules
            });
        }

        // Collection Properties
        var collectionRules = IgnoreRules.Where(r => r.PropertyPath.Contains('[') && r.PropertyPath.Contains(']'))
                                        .OrderBy(r => r.PropertyPath)
                                        .ToList();
        if (collectionRules.Any())
        {
            groups.Add(new CompactRuleGroup
            {
                Name = "Collections",
                Icon = Icons.Material.Filled.List,
                Rules = collectionRules
            });
        }

        // If only one group or few rules, don't group them
        if (groups.Count == 1 || IgnoreRules.Count <= 5)
        {
            return new List<CompactRuleGroup>
            {
                new CompactRuleGroup
                {
                    Name = "All Rules",
                    Icon = Icons.Material.Filled.Rule,
                    Rules = IgnoreRules.OrderBy(r => r.PropertyPath).ToList()
                }
            };
        }

        return groups;
    }

    // --- Export Logic ---
    private async Task ExportConfiguration()
    {
        importStatusMessage = string.Empty; // Clear any previous import status
        if (!IgnoreRules.Any())
        {
            importStatusMessage = "No rules to export.";
            importStatusIsError = true;
            return;
        }

        try
        {
            // Use a local list from the parameter to ensure we export what's shown
            var rulesToExport = IgnoreRules;
            var json = JsonSerializer.Serialize(rulesToExport, new JsonSerializerOptions { WriteIndented = true });
            var fileName = $"comparison_config_{DateTime.Now:yyyyMMdd_HHmmss}.json";

            await JSRuntime.InvokeVoidAsync("saveAsFile", fileName, "application/json", json);
        }
        catch (Exception ex)
        {
            importStatusMessage = $"Export failed: {ex.Message}";
            importStatusIsError = true;
            // Optionally log the full exception
        }
    }

    // --- Import Logic ---
    private async Task HandleImportFileSelected(InputFileChangeEventArgs e)
    {
        importStatusMessage = string.Empty;
        importStatusIsError = false;
        var file = e.File;

        if (file == null)
        {
            importStatusMessage = "No file selected.";
            importStatusIsError = true;
            return;
        }

        if (!file.Name.EndsWith(".json", StringComparison.OrdinalIgnoreCase))
        {
            importStatusMessage = "Invalid file type. Please select a .json configuration file.";
            importStatusIsError = true;
            return;
        }

        try
        {
            // Limit file size (e.g., 1MB)
            long maxFileSize = 1 * 1024 * 1024; 
            if (file.Size > maxFileSize)
            {
                 importStatusMessage = $"File size exceeds the limit of {maxFileSize / 1024 / 1024} MB.";
                 importStatusIsError = true;
                 return;
            }

            // Read and deserialize
            List<IgnoreRule> importedRules;
            await using var stream = file.OpenReadStream(maxFileSize);
            using var reader = new StreamReader(stream);
            var json = await reader.ReadToEndAsync();
            
            importedRules = JsonSerializer.Deserialize<List<IgnoreRule>>(json);

            if (importedRules == null || !importedRules.Any())
            {
                importStatusMessage = "File does not contain valid rules or is empty.";
                importStatusIsError = true;
                return;
            }

            // Clear existing rules (using the remove callback for each)
            var currentRules = IgnoreRules.ToList(); // Copy to avoid modification issues
            foreach (var rule in currentRules)
            {
                await OnIgnoreRuleRemoved.InvokeAsync(rule); 
            }
            
            // Add imported rules (using the add callback)
            foreach (var rule in importedRules)
            {
                 // Re-create the rule without IgnoreCase
                await OnIgnoreRuleAdded.InvokeAsync(new IgnoreRule 
                {
                    PropertyPath = rule.PropertyPath,
                    IgnoreCompletely = rule.IgnoreCompletely,
                    IgnoreCollectionOrder = rule.IgnoreCollectionOrder
                });
            }

            importStatusMessage = $"Successfully imported {importedRules.Count} rules.";
            importStatusIsError = false;
        }
        catch (JsonException jsonEx)
        {
            importStatusMessage = $"Import failed: Invalid JSON format. {jsonEx.Message}";
            importStatusIsError = true;
        }
        catch (Exception ex)
        {
            importStatusMessage = $"Import failed: {ex.Message}";
            importStatusIsError = true;
        }
        
        // Trigger UI update
        StateHasChanged();
    }
}
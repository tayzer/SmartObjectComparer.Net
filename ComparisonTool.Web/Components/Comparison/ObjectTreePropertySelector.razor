@using ComparisonTool.Core.Comparison.Configuration
@using System.Reflection
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.Components.Web
@using MudBlazor

<style>
    .tree-node-row {
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.15s ease;
    }
    .tree-node-row:hover {
        background-color: var(--mud-palette-action-default-hover);
    }
    .tree-node-selected {
        background-color: var(--mud-palette-primary-lighten) !important;
    }
    .tree-node-checked {
        background-color: var(--mud-palette-info-lighten) !important;
    }
    .property-code {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 0.85rem;
        word-break: break-all;
    }
</style>

<MudDialog @bind-Visible="showPropertyModal" Options="dialogOptionsExtraLarge">
    <TitleContent>
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIcon Icon="@Icons.Material.Filled.AccountTree" />
            <MudText Typo="Typo.h6">Property Tree Navigator</MudText>
            @if (IgnoredProperties.Any())
            {
                <MudChip T="string" Size="Size.Small" Color="Color.Info">@IgnoredProperties.Count rules</MudChip>
            }
        </MudStack>
    </TitleContent>
    <DialogContent>
        <MudGrid Spacing="3">
            <!-- Left Panel: Tree Navigation -->
            <MudItem xs="12" md="8">
                <MudStack Spacing="3">
                    <!-- Search and Filter Bar -->
                    <MudPaper Elevation="0" Outlined="true" Class="pa-3">
                        <MudStack Spacing="2">
                            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                <MudTextField T="string"
                                              @bind-Value="searchTerm"
                                              Placeholder="Search properties... (supports partial matching, wildcards *)"
                                              Variant="Variant.Outlined"
                                              Adornment="Adornment.Start"
                                              AdornmentIcon="@Icons.Material.Filled.Search"
                                              Immediate="true"
                                              DebounceInterval="300"
                                              OnDebounceIntervalElapsed="OnSearchChanged"
                                              Clearable="true"
                                              OnClearButtonClick="ClearSearch"
                                              Style="flex-grow: 1;"
                                              aria-label="Search properties" />
                                <MudMenu Icon="@Icons.Material.Filled.FilterList" 
                                         Variant="Variant.Outlined" 
                                         Color="@(currentSearchFilter != FilterAll ? Color.Primary : Color.Default)"
                                         aria-label="Filter properties">
                                    <MudMenuItem OnClick="@(() => SetSearchFilter(FilterAll))" 
                                                 Icon="@(currentSearchFilter == FilterAll ? Icons.Material.Filled.Check : null)">
                                        All Properties
                                    </MudMenuItem>
                                    <MudMenuItem OnClick="@(() => SetSearchFilter(FilterCollections))"
                                                 Icon="@(currentSearchFilter == FilterCollections ? Icons.Material.Filled.Check : null)">
                                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                            <MudIcon Icon="@Icons.Material.Filled.List" Size="Size.Small" />
                                            <MudText>Collections Only</MudText>
                                        </MudStack>
                                    </MudMenuItem>
                                    <MudMenuItem OnClick="@(() => SetSearchFilter(FilterPrimitives))"
                                                 Icon="@(currentSearchFilter == FilterPrimitives ? Icons.Material.Filled.Check : null)">
                                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                            <MudIcon Icon="@Icons.Material.Filled.TextFields" Size="Size.Small" />
                                            <MudText>Primitive Types</MudText>
                                        </MudStack>
                                    </MudMenuItem>
                                    <MudMenuItem OnClick="@(() => SetSearchFilter(FilterComplex))"
                                                 Icon="@(currentSearchFilter == FilterComplex ? Icons.Material.Filled.Check : null)">
                                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                            <MudIcon Icon="@Icons.Material.Filled.Category" Size="Size.Small" />
                                            <MudText>Complex Objects</MudText>
                                        </MudStack>
                                    </MudMenuItem>
                                    <MudDivider />
                                    <MudMenuItem OnClick="@(() => SetSearchFilter(FilterIgnored))"
                                                 Icon="@(currentSearchFilter == FilterIgnored ? Icons.Material.Filled.Check : null)">
                                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                            <MudIcon Icon="@Icons.Material.Filled.VisibilityOff" Size="Size.Small" Color="Color.Error" />
                                            <MudText>Currently Ignored</MudText>
                                        </MudStack>
                                    </MudMenuItem>
                                </MudMenu>
                            </MudStack>
                            
                            <!-- Active Filter Indicator -->
                            @if (currentSearchFilter != FilterAll || !string.IsNullOrEmpty(searchTerm))
                            {
                                <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                                    <MudText Typo="Typo.caption" Color="Color.Default">Active filters:</MudText>
                                    @if (!string.IsNullOrEmpty(searchTerm))
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Primary" OnClose="ClearSearch" Variant="Variant.Outlined">
                                            Search: @searchTerm
                                        </MudChip>
                                    }
                                    @if (currentSearchFilter != FilterAll)
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Secondary" OnClose="@(() => SetSearchFilter(FilterAll))" Variant="Variant.Outlined">
                                            @GetFilterDisplayName(currentSearchFilter)
                                        </MudChip>
                                    }
                                </MudStack>
                            }
                            
                            <!-- Search Suggestions -->
                            @if (searchSuggestions.Any() && !string.IsNullOrEmpty(searchTerm))
                            {
                                <MudStack Spacing="1">
                                    <MudText Typo="Typo.caption" Color="Color.Default">Quick select:</MudText>
                                    <MudStack Row="true" Spacing="1" Style="flex-wrap: wrap;">
                                        @foreach (var suggestion in searchSuggestions.Take(8))
                                        {
                                            <MudChip T="string" Size="Size.Small" 
                                                     Color="Color.Default" 
                                                     Variant="Variant.Text"
                                                     OnClick="@(() => ApplySuggestion(suggestion))"
                                                     Style="cursor: pointer;">
                                                @GetShortPropertyName(suggestion)
                                            </MudChip>
                                        }
                                    </MudStack>
                                </MudStack>
                            }
                        </MudStack>
                    </MudPaper>

                    <!-- Breadcrumb Navigation -->
                    <MudBreadcrumbs Items="@GetBreadcrumbItems()" Separator=">" MaxItems="6">
                        <ItemTemplate Context="item">
                            <MudLink Color="Color.Primary" OnClick="@(() => NavigateToBreadcrumbItem(item))">
                                @item.Text
                            </MudLink>
                        </ItemTemplate>
                        <SeparatorTemplate>
                            <MudIcon Icon="@Icons.Material.Filled.ChevronRight" Size="Size.Small" />
                        </SeparatorTemplate>
                    </MudBreadcrumbs>

                    <!-- Object Tree View -->
                    <MudPaper Elevation="0" Outlined="true" Class="pa-3" Style="max-height: 400px; overflow-y: auto;">
                        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                <MudIcon Icon="@Icons.Material.Filled.AccountTree" Size="Size.Small" />
                                <MudText Typo="Typo.subtitle2">Object Tree</MudText>
                                @if (currentSearchFilter != FilterAll)
                                {
                                    <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Outlined">@GetFilterDisplayName(currentSearchFilter)</MudChip>
                                }
                            </MudStack>
                            <MudStack Row="true" Spacing="1">
                                <MudTooltip Text="Expand all nodes">
                                    <MudIconButton Icon="@Icons.Material.Filled.UnfoldMore" Size="Size.Small" OnClick="ExpandAll" />
                                </MudTooltip>
                                <MudTooltip Text="Collapse all nodes">
                                    <MudIconButton Icon="@Icons.Material.Filled.UnfoldLess" Size="Size.Small" OnClick="CollapseAll" />
                                </MudTooltip>
                                <MudTooltip Text="Refresh tree">
                                    <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" OnClick="RefreshTree" />
                                </MudTooltip>
                            </MudStack>
                        </MudStack>
                        
                        @if (IsLoading)
                        {
                            <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center" Class="py-6">
                                <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Medium" />
                                <MudText Typo="Typo.body2" Color="Color.Default">Loading object tree...</MudText>
                            </MudStack>
                        }
                        else
                        {
                            <div class="tree-container">
                                @RenderTreeLevel(GetCurrentLevelNodes(), selectedPropertyPath)
                            </div>
                        }
                    </MudPaper>
                    
                    <!-- Bulk Selection Actions -->
                    @if (selectedProperties.Any())
                    {
                        <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Dense="true">
                            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Style="width: 100%;">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                    <MudIcon Icon="@Icons.Material.Filled.CheckBox" />
                                    <MudText Typo="Typo.body2"><strong>@selectedProperties.Count</strong> properties selected</MudText>
                                </MudStack>
                                <MudStack Row="true" Spacing="1">
                                    <MudButton Variant="Variant.Filled" 
                                               Color="Color.Success" 
                                               Size="Size.Small"
                                               StartIcon="@Icons.Material.Filled.VisibilityOff"
                                               OnClick="ShowBulkIgnoreConfirmation">
                                        Ignore All
                                    </MudButton>
                                    <MudButton Variant="Variant.Outlined" 
                                               Color="Color.Default" 
                                               Size="Size.Small"
                                               StartIcon="@Icons.Material.Filled.Clear"
                                               OnClick="ClearAllSelections">
                                        Clear
                                    </MudButton>
                                </MudStack>
                            </MudStack>
                        </MudAlert>
                    }

                    <!-- Quick Actions Bar -->
                    <MudStack Row="true" Spacing="2" Justify="Justify.FlexStart">
                        <MudButton Variant="Variant.Text" 
                                   Size="Size.Small"
                                   StartIcon="@Icons.Material.Filled.SelectAll"
                                   OnClick="ToggleSelectAllVisible">
                            @(selectAllVisible ? "Deselect All" : "Select All Visible")
                        </MudButton>
                    </MudStack>
                </MudStack>
            </MudItem>

            <!-- Right Panel: Property Configuration -->
            <MudItem xs="12" md="4">
                <MudPaper Elevation="0" Outlined="true" Class="pa-3" Style="height: 100%; min-height: 500px;">
                    <MudStack Spacing="3">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                            <MudIcon Icon="@Icons.Material.Filled.Settings" Size="Size.Small" />
                            <MudText Typo="Typo.subtitle2">Property Configuration</MudText>
                        </MudStack>
                        
                        @if (!string.IsNullOrEmpty(selectedProperty))
                        {
                            <!-- Selected Property Info -->
                            <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true">
                                <MudStack Spacing="1">
                                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Start">
                                        <MudText Typo="Typo.caption" Color="Color.Default">Selected Property</MudText>
                                        <MudIconButton Icon="@Icons.Material.Filled.Close" 
                                                       Size="Size.Small" 
                                                       OnClick="ClearSelection" />
                                    </MudStack>
                                    <MudText Typo="Typo.body2" Class="property-code">@selectedProperty</MudText>
                                </MudStack>
                            </MudAlert>

                            <!-- Property Type Info -->
                            @if (GetPropertyType(selectedProperty) != null)
                            {
                                <MudStack Spacing="1">
                                    <MudText Typo="Typo.caption" Color="Color.Default">Type Information</MudText>
                                    <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center" Style="flex-wrap: wrap;">
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Default">
                                            @GetFriendlyTypeName(GetPropertyType(selectedProperty))
                                        </MudChip>
                                        @if (IsCollectionProperty(selectedProperty))
                                        {
                                            <MudChip T="string" Size="Size.Small" Color="Color.Warning" Icon="@Icons.Material.Filled.List">
                                                Collection
                                            </MudChip>
                                        }
                                        @if (IsPrimitiveProperty(selectedProperty))
                                        {
                                            <MudChip T="string" Size="Size.Small" Color="Color.Info" Icon="@Icons.Material.Filled.TextFields">
                                                Primitive
                                            </MudChip>
                                        }
                                    </MudStack>
                                </MudStack>
                            }

                            <MudDivider />

                            <!-- Ignore Rules Configuration -->
                            <MudStack Spacing="2">
                                <MudText Typo="Typo.caption" Color="Color.Default">Ignore Options</MudText>
                                
                                <MudCheckBox T="bool" @bind-Value="IgnoreProperty" Color="Color.Error"
                                             Label="Ignore this property completely"
                                             aria-label="Ignore property completely" />
                                <MudText Typo="Typo.caption" Color="Color.Default" Style="margin-left: 32px; margin-top: -8px;">
                                    Property will be excluded from all comparisons
                                </MudText>

                                @if (IsCollectionProperty(selectedProperty))
                                {
                                    <MudCheckBox T="bool" @bind-Value="IgnoreCollectionOrder" 
                                                 Color="Color.Warning"
                                                 Disabled="@IgnoreProperty"
                                                 Label="Ignore collection ordering"
                                                 aria-label="Ignore collection ordering" />
                                    <MudText Typo="Typo.caption" Color="Color.Default" Style="margin-left: 32px; margin-top: -8px;">
                                        Items can appear in any order
                                    </MudText>
                                }
                            </MudStack>

                            <MudButton Variant="Variant.Filled" 
                                       Color="Color.Success" 
                                       FullWidth="true"
                                       StartIcon="@Icons.Material.Filled.Add"
                                       OnClick="AddCurrentProperty"
                                       Disabled="@(!IgnoreProperty && !IgnoreCollectionOrder)">
                                Add Ignore Rule
                            </MudButton>
                        }
                        else
                        {
                            <!-- Empty State -->
                            <MudAlert Severity="Severity.Normal" Variant="Variant.Outlined">
                                <MudStack AlignItems="AlignItems.Center" Spacing="2">
                                    <MudIcon Icon="@Icons.Material.Filled.TouchApp" Size="Size.Large" Color="Color.Default" />
                                    <MudText Typo="Typo.body2" Align="Align.Center">
                                        Select a property from the tree to configure ignore rules
                                    </MudText>
                                </MudStack>
                            </MudAlert>
                            
                            <MudDivider />
                            
                            <!-- Quick Add Common Properties -->
                            <MudStack Spacing="2">
                                <MudText Typo="Typo.caption" Color="Color.Default">Quick Add Common Ignores</MudText>
                                <MudStack Spacing="1">
                                    @foreach (var common in GetCommonIgnoreProperties())
                                    {
                                        <MudButton Variant="Variant.Text" 
                                                   Size="Size.Small"
                                                   FullWidth="true"
                                                   StartIcon="@Icons.Material.Filled.FlashOn"
                                                   OnClick="@(() => QuickAddProperty(common))"
                                                   Style="justify-content: flex-start;">
                                            @common
                                        </MudButton>
                                    }
                                </MudStack>
                            </MudStack>
                        }
                    </MudStack>
                </MudPaper>
            </MudItem>
        </MudGrid>

        <!-- Currently Ignored Properties Section -->
        <MudPaper Elevation="0" Outlined="true" Class="pa-3 mt-4">
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.PlaylistAddCheck" Size="Size.Small" />
                    <MudText Typo="Typo.subtitle2">Currently Ignored Properties</MudText>
                    <MudChip T="string" Size="Size.Small" Color="Color.Default" Variant="Variant.Outlined">@IgnoredProperties.Count</MudChip>
                </MudStack>
            </MudStack>
            
            @if (IgnoredProperties.Any())
            {
                <MudSimpleTable Dense="true" Hover="true" Style="max-height: 250px; overflow-y: auto;">
                    <thead>
                        <tr>
                            <th>Property Path</th>
                            <th style="width: 120px;">Type</th>
                            <th style="width: 150px;">Rules</th>
                            <th style="width: 80px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var rule in IgnoredProperties.OrderBy(r => r.PropertyPath))
                        {
                            <tr>
                                <td>
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                        <MudText Typo="Typo.body2" Class="property-code">@rule.PropertyPath</MudText>
                                        @if (IsCollectionProperty(rule.PropertyPath))
                                        {
                                            <MudChip T="string" Size="Size.Small" Color="Color.Warning" Variant="Variant.Outlined">[]</MudChip>
                                        }
                                    </MudStack>
                                </td>
                                <td>
                                    @if (GetPropertyType(rule.PropertyPath) != null)
                                    {
                                        <MudText Typo="Typo.caption">@GetFriendlyTypeName(GetPropertyType(rule.PropertyPath))</MudText>
                                    }
                                    else
                                    {
                                        <MudText Typo="Typo.caption" Color="Color.Default">Unknown</MudText>
                                    }
                                </td>
                                <td>
                                    <MudStack Row="true" Spacing="1">
                                        @if (rule.IgnoreCompletely)
                                        {
                                            <MudChip T="string" Size="Size.Small" Color="Color.Error" Variant="Variant.Filled">Ignored</MudChip>
                                        }
                                        @if (rule.IgnoreCollectionOrder)
                                        {
                                            <MudChip T="string" Size="Size.Small" Color="Color.Warning" Variant="Variant.Filled">Order</MudChip>
                                        }
                                    </MudStack>
                                </td>
                                <td>
                                    <MudStack Row="true" Spacing="0">
                                        <MudTooltip Text="Edit rule">
                                            <MudIconButton Icon="@Icons.Material.Filled.Edit" 
                                                           Size="Size.Small" 
                                                           Color="Color.Primary"
                                                           OnClick="@(() => EditIgnoredProperty(rule.PropertyPath))" />
                                        </MudTooltip>
                                        <MudTooltip Text="Remove rule">
                                            <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                                           Size="Size.Small" 
                                                           Color="Color.Error"
                                                           OnClick="@(() => RemoveIgnoredProperty(rule.PropertyPath))" />
                                        </MudTooltip>
                                    </MudStack>
                                </td>
                            </tr>
                        }
                    </tbody>
                </MudSimpleTable>
            }
            else
            {
                <MudAlert Severity="Severity.Info" Variant="Variant.Text">
                    No ignore rules configured yet. Use the tree navigator above to select and add properties.
                </MudAlert>
            }
        </MudPaper>
    </DialogContent>
    <DialogActions>
        <MudStack Row="true" Justify="Justify.SpaceBetween" Style="width: 100%;">
            <MudButton Variant="Variant.Text" 
                       Color="Color.Info" 
                       StartIcon="@Icons.Material.Filled.Help"
                       OnClick="ShowHelpModal">
                Help
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Default" OnClick="ClosePropertySelector">
                Done
            </MudButton>
        </MudStack>
    </DialogActions>
</MudDialog>

<!-- Help Modal -->
<MudDialog @bind-Visible="showHelpModal" Options="dialogOptionsLarge">
    <TitleContent>
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIcon Icon="@Icons.Material.Filled.Help" />
            <MudText Typo="Typo.h6">Property Tree Navigator Help</MudText>
        </MudStack>
    </TitleContent>
    <DialogContent>
        <MudStack Spacing="3">
            <MudExpansionPanels MultiExpansion="true">
                <MudExpansionPanel Text="Navigation Features">
                    <MudList T="string" Dense="true">
                        <MudListItem Icon="@Icons.Material.Filled.Folder">
                            <strong>Tree Navigation:</strong> Click folder icons to expand/collapse object hierarchies
                        </MudListItem>
                        <MudListItem Icon="@Icons.Material.Filled.Navigation">
                            <strong>Breadcrumbs:</strong> Click breadcrumb items to quickly navigate to parent levels
                        </MudListItem>
                        <MudListItem Icon="@Icons.Material.Filled.Search">
                            <strong>Search:</strong> Use partial matching, wildcards (*), or regex patterns
                        </MudListItem>
                        <MudListItem Icon="@Icons.Material.Filled.FilterList">
                            <strong>Filters:</strong> Filter by property types (collections, primitives, etc.)
                        </MudListItem>
                    </MudList>
                </MudExpansionPanel>
                
                <MudExpansionPanel Text="Search Examples">
                    <MudSimpleTable Dense="true">
                        <tbody>
                            <tr>
                                <td><code>Results</code></td>
                                <td>Find all properties containing "Results"</td>
                            </tr>
                            <tr>
                                <td><code>*.Name</code></td>
                                <td>Find all "Name" properties</td>
                            </tr>
                            <tr>
                                <td><code>Body.Response.*</code></td>
                                <td>Find all properties under Body.Response</td>
                            </tr>
                            <tr>
                                <td><code>[0-9]+</code></td>
                                <td>Find properties with numbers (regex)</td>
                            </tr>
                        </tbody>
                    </MudSimpleTable>
                </MudExpansionPanel>
                
                <MudExpansionPanel Text="Ignore Rule Types">
                    <MudList T="string" Dense="true">
                        <MudListItem Icon="@Icons.Material.Filled.VisibilityOff">
                            <strong>Ignore Completely:</strong> Property is excluded from all comparisons
                        </MudListItem>
                        <MudListItem Icon="@Icons.Material.Filled.SwapVert">
                            <strong>Ignore Collection Order:</strong> Array/list items can be in any order
                        </MudListItem>
                    </MudList>
                </MudExpansionPanel>
            </MudExpansionPanels>
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Filled" Color="Color.Default" OnClick="CloseHelpModal">Got it</MudButton>
    </DialogActions>
</MudDialog>

<!-- Bulk Ignore Confirmation Modal -->
<MudDialog @bind-Visible="showBulkIgnoreModal" Options="dialogOptionsRegular">
    <TitleContent>
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIcon Icon="@Icons.Material.Filled.Warning" Color="Color.Warning" />
            <MudText Typo="Typo.h6">Confirm Bulk Ignore</MudText>
        </MudStack>
    </TitleContent>
    <DialogContent>
        <MudStack Spacing="3">
            <MudText>You are about to add ignore rules for <strong>@selectedProperties.Count properties</strong>.</MudText>
            
            @if (isProcessingBulkIgnore)
            {
                <MudStack Spacing="2">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.body2">Processing...</MudText>
                        <MudText Typo="Typo.body2">@bulkIgnoreProgress%</MudText>
                    </MudStack>
                    <MudProgressLinear Value="@bulkIgnoreProgress" Color="Color.Primary" Striped="true" />
                    <MudText Typo="Typo.caption" Color="Color.Default">@bulkIgnoreStatus</MudText>
                </MudStack>
            }
            else
            {
                <MudStack Spacing="2">
                    <MudText Typo="Typo.subtitle2">Ignore Options</MudText>
                    <MudCheckBox T="bool" @bind-Value="bulkIgnoreCompletely" 
                                 Color="Color.Error"
                                 Label="Ignore completely" />
                    <MudCheckBox T="bool" @bind-Value="bulkIgnoreCollectionOrder" 
                                 Color="Color.Warning"
                                 Disabled="@bulkIgnoreCompletely"
                                 Label="Ignore collection ordering (for collection properties)" />
                </MudStack>
            }

            <MudPaper Elevation="0" Outlined="true" Class="pa-2" Style="max-height: 200px; overflow-y: auto;">
                <MudText Typo="Typo.caption" Color="Color.Default" Class="mb-2">Properties to be affected:</MudText>
                @if (selectedProperties.Count > 10)
                {
                    <MudStack Spacing="0">
                        @foreach (var prop in selectedProperties.Take(10))
                        {
                            <MudText Typo="Typo.caption" Class="property-code">• @prop</MudText>
                        }
                        <MudText Typo="Typo.caption" Color="Color.Default" Class="mt-1">
                            <em>... and @(selectedProperties.Count - 10) more properties</em>
                        </MudText>
                    </MudStack>
                }
                else
                {
                    <MudStack Spacing="0">
                        @foreach (var prop in selectedProperties)
                        {
                            <MudText Typo="Typo.caption" Class="property-code">• @prop</MudText>
                        }
                    </MudStack>
                }
            </MudPaper>
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Text" Color="Color.Default" OnClick="CancelBulkIgnore" Disabled="@isProcessingBulkIgnore">
            Cancel
        </MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Success" OnClick="ExecuteBulkIgnore" Disabled="@isProcessingBulkIgnore">
            @if (isProcessingBulkIgnore)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <text>Processing...</text>
            }
            else
            {
                <MudIcon Icon="@Icons.Material.Filled.Check" Class="mr-1" />
                <text>Confirm</text>
            }
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter] public Type ModelType { get; set; }
    [Parameter] public List<IgnoreRule> IgnoredProperties { get; set; } = new List<IgnoreRule>();
    [Parameter] public EventCallback<IgnoreRule> OnPropertyAdded { get; set; }
    [Parameter] public EventCallback<IEnumerable<IgnoreRule>> OnPropertiesBatchAdded { get; set; }
    [Parameter] public EventCallback<string> OnPropertyRemoved { get; set; }

    // Filter constants
    private const string FilterAll = "all";
    private const string FilterCollections = "collections";
    private const string FilterPrimitives = "primitives";
    private const string FilterComplex = "complex";
    private const string FilterIgnored = "ignored";

    // MudDialog visibility state
    private bool showPropertyModal = false;
    private bool showHelpModal = false;
    private bool showBulkIgnoreModal = false;
    
    // Dialog options
    private DialogOptions dialogOptionsExtraLarge = new DialogOptions 
    { 
        MaxWidth = MaxWidth.ExtraLarge, 
        FullWidth = true,
        CloseOnEscapeKey = true 
    };
    private DialogOptions dialogOptionsLarge = new DialogOptions 
    { 
        MaxWidth = MaxWidth.Large, 
        FullWidth = true,
        CloseOnEscapeKey = true 
    };
    private DialogOptions dialogOptionsRegular = new DialogOptions 
    { 
        MaxWidth = MaxWidth.Small, 
        FullWidth = true,
        CloseOnEscapeKey = true 
    };
    
    private string selectedProperty;
    private List<string> selectedPropertyPath = new List<string>();
    private string searchTerm = "";
    private string currentSearchFilter = "all";
    private bool IgnoreProperty { get; set; }
    private bool IgnoreCollectionOrder { get; set; }
    private bool IsLoading { get; set; } = false;
    
    // Bulk selection fields
    private List<string> selectedProperties = new List<string>();
    private bool selectAllVisible = false;
    private bool bulkIgnoreCompletely { get; set; } = true;
    private bool bulkIgnoreCollectionOrder { get; set; } = false;
    private bool isProcessingBulkIgnore { get; set; } = false;
    private int bulkIgnoreProgress { get; set; } = 0;
    private string bulkIgnoreStatus { get; set; } = "";

    // Tree navigation state
    private Dictionary<string, bool> expandedNodes = new Dictionary<string, bool>();
    private Dictionary<string, PropertyTreeNode> propertyTree = new Dictionary<string, PropertyTreeNode>();
    private List<string> searchSuggestions = new List<string>();

    public class PropertyTreeNode
    {
        public string Name { get; set; }
        public string FullPath { get; set; }
        public Type PropertyType { get; set; }
        public bool IsCollection { get; set; }
        public bool IsPrimitive { get; set; }
        public Dictionary<string, PropertyTreeNode> Children { get; set; } = new Dictionary<string, PropertyTreeNode>();
        public bool IsExpanded { get; set; } = false;
    }

    public async Task ShowAsync()
    {
        if (ModelType != null)
        {
            IsLoading = true;
            StateHasChanged();
            
            await Task.Delay(50); // Allow UI to update
            BuildPropertyTree();
            UpdateSearchSuggestions();
            
            IsLoading = false;
        }

        ResetSelectionState();
        showPropertyModal = true;
    }

    private void BuildPropertyTree()
    {
        propertyTree.Clear();
        expandedNodes.Clear();
        
        var allPaths = GetAllPropertyPaths(ModelType);
        
        foreach (var kvp in allPaths)
        {
            AddToTree(kvp.Key, kvp.Value);
        }
    }

         private void AddToTree(string path, Type type)
     {
         var segments = SplitPropertyPath(path);
         var currentLevel = propertyTree;
         var currentPath = "";
 
         for (int i = 0; i < segments.Count; i++)
         {
             var segment = segments[i];
             currentPath = string.IsNullOrEmpty(currentPath) ? segment : 
                          segment == "[*]" ? $"{currentPath}[*]" : $"{currentPath}.{segment}";
             
             if (!currentLevel.ContainsKey(segment))
             {
                 var isLastSegment = i == segments.Count - 1;
                 currentLevel[segment] = new PropertyTreeNode
                 {
                     Name = segment,
                     FullPath = currentPath,
                     PropertyType = isLastSegment ? type : null,
                     IsCollection = isLastSegment && IsCollectionType(type),
                     IsPrimitive = isLastSegment && IsPrimitiveType(type)
                 };
             }
             
             currentLevel = currentLevel[segment].Children;
         }
     }

     private List<string> SplitPropertyPath(string path)
     {
         var segments = new List<string>();
         var parts = path.Split('.');
         
         foreach (var part in parts)
         {
             if (part.Contains("[*]"))
             {
                 var beforeBracket = part.Substring(0, part.IndexOf("[*]"));
                 if (!string.IsNullOrEmpty(beforeBracket))
                 {
                     segments.Add(beforeBracket);
                 }
                 segments.Add("[*]");
                 
                 var afterBracket = part.Substring(part.IndexOf("[*]") + 3);
                 if (!string.IsNullOrEmpty(afterBracket))
                 {
                     segments.Add(afterBracket);
                 }
             }
             else
             {
                 segments.Add(part);
             }
         }
         
         return segments;
     }

    private RenderFragment RenderTreeLevel(Dictionary<string, PropertyTreeNode> nodes, List<string> currentPath)
    {
        return @<text>
            @foreach (var kvp in GetFilteredNodes(nodes))
            {
                var node = kvp.Value;
                var hasChildren = node.Children.Any();
                var isExpanded = IsNodeExpanded(node.FullPath);
                var indentLevel = currentPath.Count;
                var isSelected = selectedProperty == node.FullPath;
                var isChecked = selectedProperties.Contains(node.FullPath);

                <div class="tree-node-row @(isSelected ? "tree-node-selected" : "") @(isChecked ? "tree-node-checked" : "")" 
                     style="padding: 4px 8px; margin-left: @(indentLevel * 20)px;"
                     @onclick="() => SelectPropertyFromTree(node.FullPath)">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <!-- Selection checkbox -->
                        <MudCheckBox T="bool" 
                                     Value="@isChecked"
                                     ValueChanged="@((bool val) => TogglePropertySelectionDirect(node.FullPath, val))"
                                     Size="Size.Small"
                                     Color="Color.Primary"
                                     StopClickPropagation="true"
                                     aria-label="Select property" />
                        
                        @if (hasChildren)
                        {
                            <span @onclick="() => ToggleNode(node.FullPath)" @onclick:stopPropagation="true">
                                <MudIcon Icon="@(isExpanded ? Icons.Material.Filled.FolderOpen : Icons.Material.Filled.Folder)" 
                                         Size="Size.Small" 
                                         Color="@(node.Name == "[*]" ? Color.Primary : Color.Warning)"
                                         Style="cursor: pointer;"
                                         Class="mr-1" />
                            </span>
                        }
                        else
                        {
                            @if (node.Name == "[*]")
                            {
                                <MudIcon Icon="@Icons.Material.Filled.DataArray" Size="Size.Small" Color="Color.Primary" Class="mx-1" />
                            }
                            else
                            {
                                <MudIcon Icon="@Icons.Material.Filled.Description" Size="Size.Small" Color="Color.Default" Class="mx-1" />
                            }
                        }

                        <MudText Typo="@(isSelected ? Typo.subtitle2 : Typo.body2)" Style="flex-grow: 1;">
                            @if (node.Name == "[*]")
                            {
                                <text>Items</text>
                            }
                            else
                            {
                                @node.Name
                            }
                        </MudText>

                        <!-- Property type indicators -->
                        @if (node.IsCollection)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Warning" Variant="Variant.Text">[]</MudChip>
                        }
                        @if (node.IsPrimitive)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Text">P</MudChip>
                        }
                        
                        <!-- Ignore status indicator -->
                        @if (IsPropertyIgnored(node.FullPath))
                        {
                            <MudTooltip Text="Property is ignored">
                                <MudIcon Icon="@Icons.Material.Filled.VisibilityOff" Size="Size.Small" Color="Color.Error" />
                            </MudTooltip>
                        }
                    </MudStack>
                </div>

                @if (hasChildren && isExpanded)
                {
                    @RenderTreeLevel(node.Children, currentPath.Concat(new[] { node.Name }).ToList())
                }
            }
        </text>;
    }

    private void TogglePropertySelectionDirect(string propertyPath, bool isChecked)
    {
        if (isChecked && !selectedProperties.Contains(propertyPath))
        {
            selectedProperties.Add(propertyPath);
        }
        else if (!isChecked && selectedProperties.Contains(propertyPath))
        {
            selectedProperties.Remove(propertyPath);
        }
        
        UpdateSelectAllVisibleState();
        StateHasChanged();
    }

    private List<BreadcrumbItem> GetBreadcrumbItems()
    {
        var items = new List<BreadcrumbItem>
        {
            new BreadcrumbItem("Root", href: null, icon: Icons.Material.Filled.Home)
        };
        
        for (int i = 0; i < selectedPropertyPath.Count; i++)
        {
            var segment = selectedPropertyPath[i];
            var displayText = segment == "[*]" ? "Items" : segment;
            items.Add(new BreadcrumbItem(displayText, href: null));
        }
        
        return items;
    }

    private void NavigateToBreadcrumbItem(BreadcrumbItem item)
    {
        var index = GetBreadcrumbItems().IndexOf(item);
        if (index == 0)
        {
            // Root
            NavigateToBreadcrumb(new List<string>());
        }
        else if (index > 0 && index <= selectedPropertyPath.Count)
        {
            NavigateToBreadcrumb(selectedPropertyPath.Take(index).ToList());
        }
    }

    private string GetFilterDisplayName(string filter)
    {
        return filter switch
        {
            FilterCollections => "Collections",
            FilterPrimitives => "Primitives",
            FilterComplex => "Complex",
            FilterIgnored => "Ignored",
            _ => "All"
        };
    }

    private string GetShortPropertyName(string fullPath)
    {
        if (string.IsNullOrEmpty(fullPath)) return fullPath;
        var parts = fullPath.Split('.');
        return parts.Length > 2 ? $"...{parts[^2]}.{parts[^1]}" : fullPath;
    }

    private void OnSearchChanged(string value)
    {
        searchTerm = value;
        UpdateSearchSuggestions();
        StateHasChanged();
    }

    private Dictionary<string, PropertyTreeNode> GetCurrentLevelNodes()
    {
        var currentLevel = propertyTree;
        
        foreach (var segment in selectedPropertyPath)
        {
            if (currentLevel.ContainsKey(segment))
            {
                currentLevel = currentLevel[segment].Children;
            }
            else
            {
                return new Dictionary<string, PropertyTreeNode>();
            }
        }
        
        return currentLevel;
    }

    private Dictionary<string, PropertyTreeNode> GetFilteredNodes(Dictionary<string, PropertyTreeNode> nodes)
    {
        if (string.IsNullOrEmpty(searchTerm) && currentSearchFilter == "all")
            return nodes;

        var filtered = new Dictionary<string, PropertyTreeNode>();

        foreach (var kvp in nodes)
        {
            var node = kvp.Value;
            bool matches = false;

            // Apply search term filter
            if (!string.IsNullOrEmpty(searchTerm))
            {
                matches = node.FullPath.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||
                         node.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase);
                
                // Support wildcard and regex patterns
                if (!matches && searchTerm.Contains("*"))
                {
                    var regexPattern = "^" + Regex.Escape(searchTerm).Replace("\\*", ".*") + "$";
                    matches = Regex.IsMatch(node.FullPath, regexPattern, RegexOptions.IgnoreCase);
                }
            }
            else
            {
                matches = true;
            }

            // Apply type filter
            if (matches && currentSearchFilter != "all")
            {
                matches = currentSearchFilter switch
                {
                    "collections" => node.IsCollection,
                    "primitives" => node.IsPrimitive,
                    "complex" => !node.IsPrimitive && !node.IsCollection,
                    "ignored" => IsPropertyIgnored(node.FullPath),
                    _ => true
                };
            }

            if (matches)
            {
                filtered[kvp.Key] = node;
            }
        }

        return filtered;
    }

    private bool IsNodeExpanded(string path)
    {
        return expandedNodes.TryGetValue(path, out var expanded) && expanded;
    }

    private void ToggleNode(string path)
    {
        expandedNodes[path] = !IsNodeExpanded(path);
        StateHasChanged();
    }

    private void SelectPropertyFromTree(string path)
    {
        selectedProperty = path;
        
        // Update property path for breadcrumbs - handle [*] notation
        selectedPropertyPath = SplitPropertyPath(path);
        
        // Load existing rule if it exists
        var existingRule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == path);
        if (existingRule != null)
        {
            IgnoreProperty = existingRule.IgnoreCompletely;
            IgnoreCollectionOrder = existingRule.IgnoreCollectionOrder;
        }
        else
        {
            IgnoreProperty = false;
            IgnoreCollectionOrder = false;
        }

        StateHasChanged();
    }

    private void NavigateToBreadcrumb(List<string> path)
    {
        selectedPropertyPath = path.ToList();
        
        // Reconstruct the full property path
        var fullPath = ReconstructPropertyPath(path);
        if (!string.IsNullOrEmpty(fullPath))
        {
            selectedProperty = fullPath;
            
            // Load existing rule if it exists
            var existingRule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == fullPath);
            if (existingRule != null)
            {
                IgnoreProperty = existingRule.IgnoreCompletely;
                IgnoreCollectionOrder = existingRule.IgnoreCollectionOrder;
            }
            else
            {
                IgnoreProperty = false;
                IgnoreCollectionOrder = false;
            }
        }
        
        StateHasChanged();
    }

    private string ReconstructPropertyPath(List<string> segments)
    {
        if (!segments.Any()) return "";
        
        var result = "";
        for (int i = 0; i < segments.Count; i++)
        {
            var segment = segments[i];
            if (segment == "[*]")
            {
                result += "[*]";
            }
            else
            {
                if (i > 0 && segments[i - 1] != "[*]")
                {
                    result += ".";
                }
                result += segment;
            }
        }
        
        return result;
    }

    private void UpdateSearchSuggestions()
    {
        searchSuggestions.Clear();
        
        if (string.IsNullOrEmpty(searchTerm) || searchTerm.Length < 2)
            return;

        var allPaths = GetAllPropertyPaths(ModelType);
        searchSuggestions = allPaths.Keys
            .Where(path => path.Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
            .Take(10)
            .ToList();
    }

    private void ApplySuggestion(string suggestion)
    {
        searchTerm = suggestion;
        SelectPropertyFromTree(suggestion);
        UpdateSearchSuggestions();
    }

    private void SetSearchFilter(string filter)
    {
        currentSearchFilter = filter;
        StateHasChanged();
    }

    private void ClearSearch()
    {
        searchTerm = "";
        currentSearchFilter = "all";
        searchSuggestions.Clear();
        StateHasChanged();
    }

    private void ExpandAll()
    {
        foreach (var path in GetAllPropertyPaths(ModelType).Keys)
        {
            expandedNodes[path] = true;
        }
        StateHasChanged();
    }

    private void CollapseAll()
    {
        expandedNodes.Clear();
        StateHasChanged();
    }

    private void RefreshTree()
    {
        BuildPropertyTree();
        StateHasChanged();
    }

    private void ClearSelection()
    {
        selectedProperty = "";
        selectedPropertyPath.Clear();
        ResetSelectionState();
    }

    private void QuickAddProperty(string propertyPath)
    {
        selectedProperty = propertyPath;
        IgnoreProperty = true;
        IgnoreCollectionOrder = false;
        AddCurrentProperty();
    }

    private void EditIgnoredProperty(string propertyPath)
    {
        SelectPropertyFromTree(propertyPath);
    }

    private bool IsPropertyIgnored(string propertyPath)
    {
        return IgnoredProperties.Any(r => r.PropertyPath == propertyPath);
    }

    private List<string> GetCommonIgnoreProperties()
    {
        return new List<string>
        {
            "Id", "Timestamp", "CreatedDate", "ModifiedDate", 
            "Version", "RequestId", "SessionId"
        };
    }

    private void ShowHelpModal()
    {
        showHelpModal = true;
    }

    private void CloseHelpModal()
    {
        showHelpModal = false;
    }

    // ... (Include all the existing methods from HierarchicalPropertySelector like GetAllPropertyPaths, etc.)
    
    private Dictionary<string, Type> GetAllPropertyPaths(Type type, string basePath = "", int depth = 0)
    {
        var result = new Dictionary<string, Type>();

        if (depth > 10)
            return result;

        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            string path = string.IsNullOrEmpty(basePath) ? prop.Name : $"{basePath}.{prop.Name}";
            result[path] = prop.PropertyType;

            // Handle collection types - explore their item properties
            if (IsCollectionType(prop.PropertyType) && depth < 8)
            {
                var itemType = GetCollectionItemType(prop.PropertyType);
                if (itemType != null && !IsPrimitiveType(itemType))
                {
                    string collectionItemPath = $"{path}[*]";
                    result[collectionItemPath] = itemType;
                    
                    // Recursively explore collection item properties
                    var itemPaths = GetAllPropertyPaths(itemType, collectionItemPath, depth + 1);
                    foreach (var itemPath in itemPaths)
                    {
                        result[itemPath.Key] = itemPath.Value;
                    }
                }
            }
            // Handle regular complex types
            else if (!IsPrimitiveType(prop.PropertyType) && prop.PropertyType != typeof(string) && depth < 8)
            {
                var nestedPaths = GetAllPropertyPaths(prop.PropertyType, path, depth + 1);
                foreach (var nested in nestedPaths)
                {
                    result[nested.Key] = nested.Value;
                }
            }
        }

        return result;
    }

    private Type GetCollectionItemType(Type collectionType)
    {
        if (collectionType.IsArray)
        {
            return collectionType.GetElementType();
        }
        
        if (collectionType.IsGenericType)
        {
            var genericArgs = collectionType.GetGenericArguments();
            if (genericArgs.Length > 0)
            {
                return genericArgs[0];
            }
        }
        
        return null;
    }

    private bool IsPrimitiveType(Type type)
    {
        return type.IsPrimitive || type == typeof(string) || type == typeof(DateTime) || 
               type == typeof(decimal) || type == typeof(Guid) || 
               (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
    }

    private bool IsCollectionType(Type type)
    {
        return type.IsArray || 
               (type.IsGenericType && (
                   type.GetGenericTypeDefinition() == typeof(List<>) ||
                   type.GetGenericTypeDefinition() == typeof(IList<>) ||
                   type.GetGenericTypeDefinition() == typeof(IEnumerable<>) ||
                   type.GetGenericTypeDefinition() == typeof(ICollection<>)
               ));
    }

    private bool IsCollectionProperty(string propertyPath)
    {
        var type = GetPropertyType(propertyPath);
        return type != null && IsCollectionType(type);
    }

    private bool IsPrimitiveProperty(string propertyPath)
    {
        var type = GetPropertyType(propertyPath);
        return type != null && IsPrimitiveType(type);
    }

    private Type GetPropertyType(string propertyPath)
    {
        var allPaths = GetAllPropertyPaths(ModelType);
        return allPaths.TryGetValue(propertyPath, out var type) ? type : null;
    }

    private string GetFriendlyTypeName(Type type)
    {
        if (type == null) return "Unknown";

        if (type == typeof(string)) return "String";
        if (type == typeof(int)) return "Integer";
        if (type == typeof(bool)) return "Boolean";
        if (type == typeof(DateTime)) return "DateTime";
        if (type == typeof(decimal) || type == typeof(double) || type == typeof(float)) return "Number";

        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
            return GetFriendlyTypeName(type.GetGenericArguments()[0]) + "?";

        if (type.IsArray)
            return GetFriendlyTypeName(type.GetElementType()) + "[]";

        if (type.IsGenericType)
        {
            var elementType = type.GetGenericArguments().FirstOrDefault();
            if (elementType != null)
                return $"List<{GetFriendlyTypeName(elementType)}>";
            else
                return "Collection";
        }

        return type.Name;
    }

    private void ResetSelectionState()
    {
        selectedProperty = null;
        IgnoreProperty = false;
        IgnoreCollectionOrder = false;
    }

    private async Task AddCurrentProperty()
    {
        if (string.IsNullOrEmpty(selectedProperty))
            return;

        var rule = new IgnoreRule
        {
            PropertyPath = selectedProperty,
            IgnoreCompletely = IgnoreProperty,
            IgnoreCollectionOrder = IgnoreCollectionOrder
        };

        var existingRule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == selectedProperty);
        if (existingRule != null)
        {
            IgnoredProperties.Remove(existingRule);
        }

        IgnoredProperties.Add(rule);
        await OnPropertyAdded.InvokeAsync(rule);

        ResetSelectionState();
        StateHasChanged();
    }

    private async Task RemoveIgnoredProperty(string propertyPath)
    {
        var rule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == propertyPath);
        if (rule != null)
        {
            IgnoredProperties.Remove(rule);
            await OnPropertyRemoved.InvokeAsync(propertyPath);
        }
        StateHasChanged();
    }

    private void ClosePropertySelector()
    {
        showPropertyModal = false;
    }

    // Bulk selection methods
    private void ToggleSelectAllVisible()
    {
        selectAllVisible = !selectAllVisible;
        
        if (selectAllVisible)
        {
            // Select all visible properties in current tree level
            var visiblePaths = GetAllVisiblePropertyPaths();
            foreach (var path in visiblePaths)
            {
                if (!selectedProperties.Contains(path))
                {
                    selectedProperties.Add(path);
                }
            }
        }
        else
        {
            // Deselect all visible properties
            var visiblePaths = GetAllVisiblePropertyPaths();
            foreach (var path in visiblePaths)
            {
                selectedProperties.Remove(path);
            }
        }
        
        StateHasChanged();
    }

    private List<string> GetAllVisiblePropertyPaths()
    {
        var paths = new List<string>();
        CollectVisiblePaths(GetFilteredNodes(GetCurrentLevelNodes()), paths);
        return paths;
    }

    private void CollectVisiblePaths(Dictionary<string, PropertyTreeNode> nodes, List<string> paths)
    {
        foreach (var node in nodes.Values)
        {
            if (!string.IsNullOrEmpty(node.FullPath))
            {
                paths.Add(node.FullPath);
            }
            
            if (IsNodeExpanded(node.FullPath))
            {
                CollectVisiblePaths(node.Children, paths);
            }
        }
    }

    private void UpdateSelectAllVisibleState()
    {
        var visiblePaths = GetAllVisiblePropertyPaths();
        if (visiblePaths.Any())
        {
            selectAllVisible = visiblePaths.All(path => selectedProperties.Contains(path));
        }
        else
        {
            selectAllVisible = false;
        }
    }

    private void ShowBulkIgnoreConfirmation()
    {
        if (!selectedProperties.Any())
            return;

        // Reset bulk ignore settings to defaults
        bulkIgnoreCompletely = true;
        bulkIgnoreCollectionOrder = false;
        
        showBulkIgnoreModal = true;
    }

    private async Task ExecuteBulkIgnore()
    {
        if (!selectedProperties.Any())
            return;

        try
        {
            // Show loading state
            isProcessingBulkIgnore = true;
            bulkIgnoreProgress = 0;
            var propertiesCount = selectedProperties.Count;
            bulkIgnoreStatus = $"Starting bulk ignore for {propertiesCount} properties...";
            StateHasChanged();
            
            Console.WriteLine($"Starting bulk ignore for {propertiesCount} properties...");

            // Process in batches to avoid UI freezing
            var batchSize = 50; // Process 50 properties at a time
            var batches = selectedProperties
                .Select((property, index) => new { property, index })
                .GroupBy(x => x.index / batchSize)
                .Select(g => g.Select(x => x.property).ToList())
                .ToList();

            var processedCount = 0;

            for (int batchIndex = 0; batchIndex < batches.Count; batchIndex++)
            {
                var batch = batches[batchIndex];
                bulkIgnoreStatus = $"Processing batch {batchIndex + 1}/{batches.Count} ({batch.Count} properties)";
                Console.WriteLine(bulkIgnoreStatus);

                var batchRules = new List<IgnoreRule>();
                
                foreach (var propertyPath in batch)
                {
                    var rule = new IgnoreRule
                    {
                        PropertyPath = propertyPath,
                        IgnoreCompletely = bulkIgnoreCompletely,
                        IgnoreCollectionOrder = !bulkIgnoreCompletely && bulkIgnoreCollectionOrder && IsCollectionProperty(propertyPath)
                    };

                    // Remove existing rule for this property if it exists
                    var existingRule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == propertyPath);
                    if (existingRule != null)
                    {
                        IgnoredProperties.Remove(existingRule);
                    }

                    IgnoredProperties.Add(rule);
                    batchRules.Add(rule);
                    
                    processedCount++;
                    bulkIgnoreProgress = (int)((double)processedCount / propertiesCount * 100);
                }

                // Process entire batch at once for better performance
                if (OnPropertiesBatchAdded.HasDelegate)
                {
                    await OnPropertiesBatchAdded.InvokeAsync(batchRules);
                }
                else
                {
                    // Fallback to individual processing if batch method not available
                    foreach (var rule in batchRules)
                    {
                        await OnPropertyAdded.InvokeAsync(rule);
                    }
                }

                // Allow UI to update between batches
                StateHasChanged();
                await Task.Delay(10); // Small delay to prevent UI blocking
            }

            bulkIgnoreStatus = $"Bulk ignore completed successfully for {propertiesCount} properties";
            Console.WriteLine(bulkIgnoreStatus);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during bulk ignore: {ex.Message}");
            // Continue with cleanup even if there was an error
        }
        finally
        {
            // Clear selections and close modal
            isProcessingBulkIgnore = false;
            bulkIgnoreProgress = 0;
            bulkIgnoreStatus = "";
            selectedProperties.Clear();
            selectAllVisible = false;
            showBulkIgnoreModal = false;
            StateHasChanged();
        }
    }

    private void CancelBulkIgnore()
    {
        showBulkIgnoreModal = false;
    }

    private void ClearAllSelections()
    {
        selectedProperties.Clear();
        selectAllVisible = false;
        StateHasChanged();
    }
}
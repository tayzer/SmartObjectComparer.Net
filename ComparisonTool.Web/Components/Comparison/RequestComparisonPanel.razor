@using System.Net.Http.Json
@using ComparisonTool.Core.Comparison.Configuration
@using ComparisonTool.Core.Comparison.Results
@using ComparisonTool.Core.RequestComparison.Models
@using ComparisonTool.Core.RequestComparison.Services
@using ComparisonTool.Core.Serialization
@using ComparisonTool.Web.Models
@using ComparisonTool.Web.Services
@using Microsoft.Extensions.Options
@using Microsoft.AspNetCore.Components.Forms
@using MudBlazor
@inject IHttpClientFactory HttpClientFactory
@inject ILogger<RequestComparisonPanel> Logger
@inject NavigationManager NavigationManager
@inject IConfiguration Configuration
@inject IOptions<RequestComparisonEndpointOptions> EndpointOptions
@inject IDeserializationService DeserializationService
@inject IComparisonConfigurationService ConfigService
@inject RequestComparisonJobService JobService
@inject ComparisonProgressService ProgressService
@implements IAsyncDisposable

<MudPaper Elevation="2" Class="pa-4">
    <MudStack Spacing="3">
        <MudText Typo="Typo.h6">Request Comparison</MudText>
        <MudText Typo="Typo.body2" Color="Color.Default">
            Upload request files and compare responses from two endpoints.
        </MudText>

        @* Step 1: Upload Request Files *@
        <MudPaper Elevation="1" Class="pa-3" Style="background-color: var(--mud-palette-background-grey);">
            <MudStack Spacing="2">
                <MudText Typo="Typo.subtitle1">Step 1: Upload Request Files</MudText>
                <InputFile OnChange="HandleFileSelection" multiple accept="*/*" />
                @if (selectedFiles != null && selectedFiles.Count > 0)
                {
                    <MudText Typo="Typo.caption">@selectedFiles.Count files selected</MudText>
                }
                <MudButton Variant="Variant.Filled" 
                           Color="Color.Primary" 
                           StartIcon="@Icons.Material.Filled.CloudUpload"
                           OnClick="UploadFiles"
                           Disabled="@(selectedFiles == null || selectedFiles.Count == 0 || isUploading || cacheHit)">
                    @if (isUploading)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <text>Uploading...</text>
                    }
                    else
                    {
                        <text>Upload Request Files</text>
                    }
                </MudButton>
                @if (!string.IsNullOrEmpty(batchId))
                {
                    <MudAlert Severity="Severity.Success" Variant="Variant.Outlined">
                        Uploaded @uploadedCount files. Batch ID: @batchId
                    </MudAlert>
                }
                @if (cacheHit && !string.IsNullOrEmpty(batchId))
                {
                    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined">
                        Cache hit. Using cached batch ID: @batchId
                    </MudAlert>
                }
            </MudStack>
        </MudPaper>

        @* Step 2: Model & Configuration *@
        <MudPaper Elevation="1" Class="pa-3" Style="background-color: var(--mud-palette-background-grey);">
            <MudStack Spacing="2">
                <MudText Typo="Typo.subtitle1">Step 2: Model & Configuration</MudText>
                
                <MudSelect T="string" 
                           Label="Select Domain Model" 
                           Value="selectedModelName"
                           ValueChanged="@((string val) => selectedModelName = val)"
                           Variant="Variant.Outlined"
                           AnchorOrigin="Origin.BottomCenter">
                    @foreach (var modelName in availableModels)
                    {
                        <MudSelectItem Value="@modelName">@modelName</MudSelectItem>
                    }
                </MudSelect>

                <MudExpansionPanels>
                    <MudExpansionPanel Text="Comparison Options">
                        <MudStack Spacing="2">
                            <MudSwitch @bind-Value="ignoreCollectionOrder" 
                                       Label="Ignore Collection Order" 
                                       Color="Color.Primary" />
                            <MudSwitch @bind-Value="ignoreStringCase" 
                                       Label="Ignore String Case" 
                                       Color="Color.Primary" />
                            <MudSwitch @bind-Value="ignoreXmlNamespaces" 
                                       Label="Ignore XML Namespaces" 
                                       Color="Color.Primary" />
                        </MudStack>
                    </MudExpansionPanel>
                    
                    <MudExpansionPanel Text="Analysis Options">
                        <MudStack Spacing="2">
                            <MudSwitch @bind-Value="enableSemanticAnalysis" 
                                       Label="Enable Semantic Analysis" 
                                       Color="Color.Success" />
                            <MudSwitch @bind-Value="enableEnhancedStructuralAnalysis" 
                                       Label="Enable Enhanced Structural Analysis" 
                                       Color="Color.Success" />
                        </MudStack>
                    </MudExpansionPanel>
                    
                    <MudExpansionPanel Text="@IgnoreRulesLabel">
                        <MudStack Spacing="2">
                            <MudText Typo="Typo.subtitle2">Tree Navigator (Visual Property Selection)</MudText>
                            <MudStack Row="true" Spacing="2">
                                <MudButton Variant="Variant.Outlined" 
                                           Size="Size.Small"
                                           StartIcon="@Icons.Material.Filled.List"
                                           OnClick="OpenPropertySelector" 
                                           Disabled="@(!IsModelSelected)">
                                    Simple Property Selector
                                </MudButton>
                                <MudButton Variant="Variant.Outlined" 
                                           Size="Size.Small"
                                           Color="Color.Success"
                                           StartIcon="@Icons.Material.Filled.AccountTree"
                                           OnClick="OpenTreePropertySelector" 
                                           Disabled="@(!IsModelSelected)">
                                    Tree Navigator ⭐
                                </MudButton>
                            </MudStack>
                            @if (!IsModelSelected)
                            {
                                <MudText Typo="Typo.caption" Color="Color.Default">
                                    Select a model first to browse and ignore properties.
                                </MudText>
                            }
                            
                            <MudDivider Class="my-2" />
                            
                            @if (IgnoreRules.Any())
                            {
                                <MudPaper Outlined="true" Style="max-height: 200px; overflow-y: auto;">
                                    @foreach (var rule in IgnoreRules.OrderBy(r => r.PropertyPath))
                                    {
                                        <MudStack Row="true" Class="pa-2" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                            <MudText Typo="Typo.body2" Style="font-family: 'Consolas', 'Monaco', monospace; word-break: break-all;">
                                                @rule.PropertyPath
                                            </MudText>
                                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                                @if (rule.IgnoreCompletely)
                                                {
                                                    <MudChip T="string" Size="Size.Small" Color="Color.Error" Icon="@Icons.Material.Filled.VisibilityOff">
                                                        Ignore
                                                    </MudChip>
                                                }
                                                @if (rule.IgnoreCollectionOrder)
                                                {
                                                    <MudChip T="string" Size="Size.Small" Color="Color.Warning" Icon="@Icons.Material.Filled.SwapVert">
                                                        Order
                                                    </MudChip>
                                                }
                                                <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                               Size="Size.Small"
                                                               Color="Color.Error"
                                                               OnClick="@(() => RemoveIgnoreRule(rule))" />
                                            </MudStack>
                                        </MudStack>
                                        <MudDivider />
                                    }
                                </MudPaper>
                                <MudButton Variant="Variant.Text" 
                                           Size="Size.Small"
                                           Color="Color.Error"
                                           StartIcon="@Icons.Material.Filled.DeleteSweep"
                                           OnClick="ClearAllIgnoreRules">
                                    Clear All Rules
                                </MudButton>
                            }
                            else
                            {
                                <MudPaper Outlined="true" Class="pa-4" Style="text-align: center;">
                                    <MudStack Row="true" Justify="Justify.Center" AlignItems="AlignItems.Center" Spacing="2">
                                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Default" />
                                        <MudText Typo="Typo.body2" Color="Color.Default">No ignore rules configured</MudText>
                                    </MudStack>
                                </MudPaper>
                            }
                        </MudStack>
                    </MudExpansionPanel>
                </MudExpansionPanels>
            </MudStack>
        </MudPaper>

        @* Step 3: Configure Endpoints *@
        <MudPaper Elevation="1" Class="pa-3" Style="background-color: var(--mud-palette-background-grey);">
            <MudStack Spacing="2">
                <MudText Typo="Typo.subtitle1">Step 3: Configure Endpoints</MudText>
                <MudSelect T="string" Label="Endpoint A" Variant="Variant.Outlined" Value="selectedEndpointA" ValueChanged="OnEndpointAChanged">
                    @foreach (var option in availableEndpoints)
                    {
                        <MudSelectItem Value="@option.Url">@option.Name (@option.Url)</MudSelectItem>
                    }
                    @if (allowCustom)
                    {
                        <MudSelectItem Value="@CustomEndpointValue">Custom...</MudSelectItem>
                    }
                </MudSelect>
                @if (allowCustom && selectedEndpointA == CustomEndpointValue)
                {
                    <MudTextField @bind-Value="endpointA" 
                                  Label="Endpoint A URL" 
                                  Placeholder="https://api-a.example.com/endpoint"
                                  Variant="Variant.Outlined" />
                }

                <MudSelect T="string" Label="Endpoint B" Variant="Variant.Outlined" Value="selectedEndpointB" ValueChanged="OnEndpointBChanged">
                    @foreach (var option in availableEndpoints)
                    {
                        <MudSelectItem Value="@option.Url">@option.Name (@option.Url)</MudSelectItem>
                    }
                    @if (allowCustom)
                    {
                        <MudSelectItem Value="@CustomEndpointValue">Custom...</MudSelectItem>
                    }
                </MudSelect>
                @if (allowCustom && selectedEndpointB == CustomEndpointValue)
                {
                    <MudTextField @bind-Value="endpointB" 
                                  Label="Endpoint B URL" 
                                  Placeholder="https://api-b.example.com/endpoint"
                                  Variant="Variant.Outlined" />
                }
                
                <MudExpansionPanels>
                    <MudExpansionPanel Text="Custom Headers (Optional)">
                        <MudStack Spacing="2">
                            <MudText Typo="Typo.subtitle2">Headers for Endpoint A</MudText>
                            @foreach (var header in headersA)
                            {
                                <MudStack Row="true" Spacing="2">
                                    <MudTextField @bind-Value="header.Key" Label="Header Name" Variant="Variant.Outlined" />
                                    <MudTextField @bind-Value="header.Value" Label="Header Value" Variant="Variant.Outlined" />
                                    <MudIconButton Icon="@Icons.Material.Filled.Delete" OnClick="@(() => headersA.Remove(header))" />
                                </MudStack>
                            }
                            <MudButton Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Add" OnClick="@(() => headersA.Add(new HeaderPair()))">
                                Add Header
                            </MudButton>
                            
                            <MudText Typo="Typo.subtitle2">Headers for Endpoint B</MudText>
                            @foreach (var header in headersB)
                            {
                                <MudStack Row="true" Spacing="2">
                                    <MudTextField @bind-Value="header.Key" Label="Header Name" Variant="Variant.Outlined" />
                                    <MudTextField @bind-Value="header.Value" Label="Header Value" Variant="Variant.Outlined" />
                                    <MudIconButton Icon="@Icons.Material.Filled.Delete" OnClick="@(() => headersB.Remove(header))" />
                                </MudStack>
                            }
                            <MudButton Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Add" OnClick="@(() => headersB.Add(new HeaderPair()))">
                                Add Header
                            </MudButton>
                        </MudStack>
                    </MudExpansionPanel>
                    <MudExpansionPanel Text="Advanced Options">
                        <MudStack Spacing="2">
                            <MudTextField @bind-Value="contentTypeOverride"
                                          Label="Content-Type Override"
                                          Placeholder="application/json"
                                          Variant="Variant.Outlined" />
                            <MudText Typo="Typo.caption" Color="Color.Default">
                                Optional. Overrides the request content type inferred from file extension.
                            </MudText>
                            <MudNumericField @bind-Value="timeoutMs" 
                                             Label="Request Timeout (ms)" 
                                             Min="1000" Max="300000" 
                                             Variant="Variant.Outlined" />
                            <MudNumericField @bind-Value="maxConcurrency" 
                                             Label="Max Concurrency" 
                                             Min="1" Max="256" 
                                             Variant="Variant.Outlined" />
                        </MudStack>
                    </MudExpansionPanel>
                </MudExpansionPanels>
            </MudStack>
        </MudPaper>

        @* Step 4: Run Comparison *@
        <MudPaper Elevation="1" Class="pa-3" Style="background-color: var(--mud-palette-background-grey);">
            <MudStack Spacing="2">
                <MudText Typo="Typo.subtitle1">Step 4: Run Comparison</MudText>
                <MudButton Variant="Variant.Filled" 
                           Color="Color.Success" 
                           StartIcon="@Icons.Material.Filled.PlayArrow"
                           OnClick="StartComparison"
                           Disabled="@(!CanStartComparison)">
                    Start Comparison
                </MudButton>
                
                @if (isRunning)
                {
                    <MudStack Spacing="2">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudIcon Icon="@GetPhaseIcon()" Color="@GetPhaseColor()" />
                            <MudText Typo="Typo.subtitle2" Color="@GetPhaseColor()">@currentPhase</MudText>
                        </MudStack>
                        
                        <MudProgressLinear Color="@GetPhaseColor()" 
                                           Value="@progressPercent" 
                                           Striped="true"
                                           Size="Size.Large">
                            <MudText Typo="Typo.caption">@progressPercent%</MudText>
                        </MudProgressLinear>
                        
                        <MudText Typo="Typo.body2">@statusMessage</MudText>
                        
                        @if (progressLog.Count > 0)
                        {
                            <MudExpansionPanels>
                                <MudExpansionPanel Text="@($"Activity Log ({progressLog.Count} events)")">
                                    <MudList T="string" Dense="true" Style="max-height: 200px; overflow-y: auto;">
                                        @foreach (var entry in progressLog.AsEnumerable().Reverse().Take(15))
                                        {
                                            <MudListItem T="string">
                                                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                                    <MudText Typo="Typo.caption" Color="Color.Default" Style="font-family: monospace; min-width: 70px;">
                                                        @entry.Timestamp.ToLocalTime().ToString("HH:mm:ss")
                                                    </MudText>
                                                    <MudChip T="string" Size="Size.Small" Color="@GetPhaseChipColor(entry.Phase)" Variant="Variant.Outlined">
                                                        @entry.Phase
                                                    </MudChip>
                                                    <MudText Typo="Typo.body2">@entry.Message</MudText>
                                                </MudStack>
                                            </MudListItem>
                                        }
                                    </MudList>
                                </MudExpansionPanel>
                            </MudExpansionPanels>
                        }
                        
                        <MudButton Variant="Variant.Outlined" 
                                   Color="Color.Warning" 
                                   StartIcon="@Icons.Material.Filled.Cancel"
                                   OnClick="CancelJob">
                            Cancel
                        </MudButton>
                    </MudStack>
                }
                
                @if (!string.IsNullOrEmpty(errorMessage))
                {
                    <MudAlert Severity="Severity.Error" Variant="Variant.Outlined">
                        @errorMessage
                    </MudAlert>
                }
            </MudStack>
        </MudPaper>
    </MudStack>
</MudPaper>

@code {
    [Parameter] public EventCallback<MultiFolderComparisonResult> OnComparisonComplete { get; set; }
    private const string CustomEndpointValue = "__custom__";

    private List<IBrowserFile>? selectedFiles;
    private bool isUploading = false;
    private string? batchId;
    private int uploadedCount = 0;
    
    // Model & Configuration
    private List<string> availableModels = new();
    private string selectedModelName = "";
    private bool ignoreCollectionOrder = false;
    private bool ignoreStringCase = false;
    private bool ignoreXmlNamespaces = true;
    private bool enableSemanticAnalysis = true;
    private bool enableEnhancedStructuralAnalysis = true;
    public List<IgnoreRule> IgnoreRules { get; set; } = new();
    
    // Event callbacks for property selectors
    [Parameter] public EventCallback OnPropertySelectorOpened { get; set; }
    [Parameter] public EventCallback OnTreePropertySelectorOpened { get; set; }
    
    // Endpoints
    private string endpointA = "";
    private string endpointB = "";
    private List<RequestComparisonEndpointOption> availableEndpoints = new();
    private bool allowCustom = true;
    private string selectedEndpointA = CustomEndpointValue;
    private string selectedEndpointB = CustomEndpointValue;
    private List<HeaderPair> headersA = new();
    private List<HeaderPair> headersB = new();
    private string? contentTypeOverride;
    private int timeoutMs = 30000;
    private int maxConcurrency = 64;
    
    private bool isRunning = false;
    private string? currentJobId;
    private int progressPercent = 0;
    private string? statusMessage;
    private string? errorMessage;
    private CancellationTokenSource? cts;
    private string? cacheKey;
    private bool cacheHit = false;
    
    // Progress tracking
    private string currentPhase = "Initializing";
    private List<(DateTimeOffset Timestamp, string Phase, string Message)> progressLog = new();

    private bool CanStartComparison => 
        !string.IsNullOrEmpty(batchId) && 
        !string.IsNullOrWhiteSpace(endpointA) && 
        !string.IsNullOrWhiteSpace(endpointB) && 
        !string.IsNullOrWhiteSpace(selectedModelName) &&
        !isRunning;
    
    private bool IsModelSelected => !string.IsNullOrEmpty(selectedModelName);
    private string IgnoreRulesLabel => $"Ignore Rules ({IgnoreRules.Count} rules)";

    protected override void OnInitialized()
    {
        // Subscribe to progress updates
        ProgressService.OnProgressUpdate += HandleProgressUpdate;
        
        // Load available models
        availableModels = DeserializationService.GetRegisteredModelNames().ToList();
        if (availableModels.Count > 0)
        {
            selectedModelName = availableModels[0];
        }
        
        var options = EndpointOptions.Value;
        allowCustom = options.AllowCustom;
        availableEndpoints = options.Endpoints ?? new List<RequestComparisonEndpointOption>();

        if (availableEndpoints.Count > 0)
        {
            selectedEndpointA = availableEndpoints[0].Url;
            endpointA = availableEndpoints[0].Url;

            selectedEndpointB = availableEndpoints.Count > 1
                ? availableEndpoints[1].Url
                : availableEndpoints[0].Url;
            endpointB = selectedEndpointB;
        }

        timeoutMs = Configuration.GetValue("RequestComparison:DefaultTimeoutMs", 30000);
        maxConcurrency = Configuration.GetValue("RequestComparison:MaxConcurrency", 64);
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        selectedFiles = e.GetMultipleFiles(10000).ToList();
        errorMessage = null;
        cacheHit = false;
        batchId = null;
        uploadedCount = 0;

        if (selectedFiles.Count > 0)
        {
            cacheKey = ComputeCacheKey(selectedFiles);
            await TryResolveCachedBatchAsync();
        }
    }

    private async Task UploadFiles()
    {
        if (selectedFiles == null || selectedFiles.Count == 0) return;
        if (cacheHit && !string.IsNullOrEmpty(batchId)) return;

        isUploading = true;
        errorMessage = null;
        
        try
        {
            using var http = HttpClientFactory.CreateClient();
            http.BaseAddress = new Uri(NavigationManager.BaseUri);
            
            using var content = new MultipartFormDataContent();
            if (!string.IsNullOrWhiteSpace(cacheKey))
            {
                content.Add(new StringContent(cacheKey), "cacheKey");
            }
            foreach (var file in selectedFiles)
            {
                var stream = file.OpenReadStream(maxAllowedSize: 100 * 1024 * 1024);
                content.Add(new StreamContent(stream), "files", file.Name);
            }

            var response = await http.PostAsync("/api/requests/batch", content);
            response.EnsureSuccessStatusCode();
            
            var result = await response.Content.ReadFromJsonAsync<RequestBatchUploadResponse>();
            batchId = result?.BatchId;
            uploadedCount = result?.Uploaded ?? 0;
            cacheHit = result?.CacheHit ?? false;
        }
        catch (Exception ex)
        {
            errorMessage = $"Upload failed: {ex.Message}";
            Logger.LogError(ex, "Failed to upload request files");
        }
        finally
        {
            isUploading = false;
        }
    }

    private async Task StartComparison()
    {
        if (!CanStartComparison) return;

        isRunning = true;
        errorMessage = null;
        progressPercent = 0;
        statusMessage = "Starting comparison...";
        currentPhase = "Initializing";
        progressLog.Clear();
        cts = new CancellationTokenSource();

        try
        {
            using var http = HttpClientFactory.CreateClient();
            http.BaseAddress = new Uri(NavigationManager.BaseUri);

            var request = new CreateRequestComparisonJobRequest
            {
                RequestBatchId = batchId!,
                EndpointA = endpointA,
                EndpointB = endpointB,
                HeadersA = headersA.Where(h => !string.IsNullOrEmpty(h.Key))
                    .ToDictionary(h => h.Key, h => h.Value ?? ""),
                HeadersB = headersB.Where(h => !string.IsNullOrEmpty(h.Key))
                    .ToDictionary(h => h.Key, h => h.Value ?? ""),
                ContentTypeOverride = string.IsNullOrWhiteSpace(contentTypeOverride)
                    ? null
                    : contentTypeOverride,
                TimeoutMs = timeoutMs,
                MaxConcurrency = maxConcurrency,
                // Configuration parity with Home
                ModelName = selectedModelName,
                IgnoreCollectionOrder = ignoreCollectionOrder,
                IgnoreStringCase = ignoreStringCase,
                IgnoreXmlNamespaces = ignoreXmlNamespaces,
                EnableSemanticAnalysis = enableSemanticAnalysis,
                EnableEnhancedStructuralAnalysis = enableEnhancedStructuralAnalysis,
                IgnoreRules = IgnoreRules.Where(r => !string.IsNullOrWhiteSpace(r.PropertyPath))
                    .Select(r => new IgnoreRuleDto 
                    { 
                        PropertyPath = r.PropertyPath, 
                        IgnoreCompletely = r.IgnoreCompletely, 
                        IgnoreCollectionOrder = r.IgnoreCollectionOrder 
                    }).ToList(),
                SmartIgnoreRules = new List<SmartIgnoreRuleDto>()
            };

            var createResponse = await http.PostAsJsonAsync("/api/requests/compare", request);
            createResponse.EnsureSuccessStatusCode();
            
            var createResult = await createResponse.Content.ReadFromJsonAsync<CreateJobResponse>();
            currentJobId = createResult?.JobId;

            // Subscribe to SignalR progress updates
            if (!string.IsNullOrEmpty(currentJobId))
            {
                await ProgressService.SubscribeToJobAsync(currentJobId);
            }

            // Poll for status as fallback (reduced frequency since SignalR handles most updates)
            while (!cts.Token.IsCancellationRequested)
            {
                await Task.Delay(2000, cts.Token);
                
                var statusResponse = await http.GetFromJsonAsync<JobStatusResponse>(
                    $"/api/requests/compare/{currentJobId}/status");
                
                if (statusResponse == null) continue;

                if (statusResponse.Status == "Completed")
                {
                    var result = JobService.GetResult(currentJobId!);
                    if (result != null)
                    {
                        await OnComparisonComplete.InvokeAsync(result);
                    }
                    break;
                }
                else if (statusResponse.Status == "Failed")
                {
                    errorMessage = statusResponse.Error ?? "Job failed";
                    break;
                }
                else if (statusResponse.Status == "Cancelled")
                {
                    statusMessage = "Job was cancelled";
                    break;
                }
            }
        }
        catch (OperationCanceledException)
        {
            statusMessage = "Cancelled";
        }
        catch (Exception ex)
        {
            errorMessage = $"Comparison failed: {ex.Message}";
            Logger.LogError(ex, "Request comparison failed");
        }
        finally
        {
            isRunning = false;
            await ProgressService.UnsubscribeAsync();
            cts?.Dispose();
            cts = null;
        }
    }

    private async Task CancelJob()
    {
        if (string.IsNullOrEmpty(currentJobId)) return;
        
        cts?.Cancel();
        
        try
        {
            using var http = HttpClientFactory.CreateClient();
            http.BaseAddress = new Uri(NavigationManager.BaseUri);
            await http.PostAsync($"/api/requests/compare/{currentJobId}/cancel", null);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to cancel job");
        }
    }

    private void OnEndpointAChanged(string value)
    {
        selectedEndpointA = value;
        if (value != CustomEndpointValue)
        {
            endpointA = value;
        }
    }

    private void OnEndpointBChanged(string value)
    {
        selectedEndpointB = value;
        if (value != CustomEndpointValue)
        {
            endpointB = value;
        }
    }

    private async Task TryResolveCachedBatchAsync()
    {
        if (string.IsNullOrWhiteSpace(cacheKey)) return;

        try
        {
            using var http = HttpClientFactory.CreateClient();
            http.BaseAddress = new Uri(NavigationManager.BaseUri);

            var response = await http.GetAsync($"/api/requests/batch/cache/{cacheKey}");
            if (!response.IsSuccessStatusCode)
            {
                return;
            }

            var cacheResponse = await response.Content.ReadFromJsonAsync<RequestBatchCacheLookupResponse>();
            if (cacheResponse?.Found == true && !string.IsNullOrEmpty(cacheResponse.BatchId))
            {
                batchId = cacheResponse.BatchId;
                uploadedCount = cacheResponse.Uploaded;
                cacheHit = true;
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to resolve cached request batch");
        }
    }

    private static string ComputeCacheKey(IEnumerable<IBrowserFile> files)
    {
        var ordered = files.OrderBy(f => f.Name, StringComparer.Ordinal);
        var builder = new System.Text.StringBuilder();
        foreach (var file in ordered)
        {
            builder.Append(file.Name)
                .Append('|')
                .Append(file.Size)
                .Append('|')
                .Append(file.LastModified.ToUnixTimeMilliseconds())
                .Append(';');
        }

        var bytes = System.Text.Encoding.UTF8.GetBytes(builder.ToString());
        var hash = System.Security.Cryptography.SHA256.HashData(bytes);
        return Convert.ToHexString(hash).ToLowerInvariant();
    }

    private async Task OpenPropertySelector()
    {
        await OnPropertySelectorOpened.InvokeAsync();
    }

    private async Task OpenTreePropertySelector()
    {
        await OnTreePropertySelectorOpened.InvokeAsync();
    }

    public void AddIgnoreRule(IgnoreRule rule)
    {
        var existingRule = IgnoreRules.FirstOrDefault(r => r.PropertyPath == rule.PropertyPath);
        if (existingRule != null)
        {
            IgnoreRules.Remove(existingRule);
        }
        IgnoreRules.Add(rule);
        StateHasChanged();
    }

    public void AddIgnoreRulesBatch(IEnumerable<IgnoreRule> rules)
    {
        foreach (var rule in rules)
        {
            var existingRule = IgnoreRules.FirstOrDefault(r => r.PropertyPath == rule.PropertyPath);
            if (existingRule != null)
            {
                IgnoreRules.Remove(existingRule);
            }
            IgnoreRules.Add(rule);
        }
        StateHasChanged();
    }

    private void RemoveIgnoreRule(IgnoreRule rule)
    {
        IgnoreRules.Remove(rule);
        StateHasChanged();
    }

    private void ClearAllIgnoreRules()
    {
        IgnoreRules.Clear();
        StateHasChanged();
    }

    public Type? GetSelectedModelType()
    {
        if (string.IsNullOrEmpty(selectedModelName))
            return null;
        try
        {
            return DeserializationService.GetModelType(selectedModelName);
        }
        catch
        {
            return null;
        }
    }

    private void HandleProgressUpdate(ComparisonProgressUpdate update)
    {
        // Ignore updates that don't belong to the current job
        if (update.JobId != currentJobId)
        {
            return;
        }

        InvokeAsync(() =>
        {
            // Only update if progress is moving forward (or it's a phase change)
            if (update.PercentComplete >= progressPercent || update.Phase.ToString() != currentPhase)
            {
                currentPhase = update.Phase.ToString();
                progressPercent = update.PercentComplete;
                statusMessage = update.Message;
                
                // Add to log
                progressLog.Add((update.Timestamp, update.Phase.ToString(), update.Message));
                
                // Keep only last 50 entries
                if (progressLog.Count > 50)
                {
                    progressLog = progressLog.Skip(progressLog.Count - 50).ToList();
                }
                
                StateHasChanged();
            }
        });
    }

    private string GetPhaseIcon() => currentPhase switch
    {
        "Initializing" => Icons.Material.Filled.HourglassEmpty,
        "Parsing" => Icons.Material.Filled.Description,
        "Executing" => Icons.Material.Filled.Send,
        "Comparing" => Icons.Material.Filled.CompareArrows,
        "Completed" => Icons.Material.Filled.CheckCircle,
        "Failed" => Icons.Material.Filled.Error,
        "Cancelled" => Icons.Material.Filled.Cancel,
        _ => Icons.Material.Filled.Info
    };

    private Color GetPhaseColor() => currentPhase switch
    {
        "Initializing" => Color.Default,
        "Parsing" => Color.Info,
        "Executing" => Color.Primary,
        "Comparing" => Color.Secondary,
        "Completed" => Color.Success,
        "Failed" => Color.Error,
        "Cancelled" => Color.Warning,
        _ => Color.Default
    };

    private Color GetPhaseChipColor(string phase) => phase switch
    {
        "Initializing" => Color.Default,
        "Parsing" => Color.Info,
        "Executing" => Color.Primary,
        "Comparing" => Color.Secondary,
        "Completed" => Color.Success,
        "Failed" => Color.Error,
        "Cancelled" => Color.Warning,
        _ => Color.Default
    };

    public async ValueTask DisposeAsync()
    {
        ProgressService.OnProgressUpdate -= HandleProgressUpdate;
        await ProgressService.UnsubscribeAsync();
    }

    private class HeaderPair
    {
        public string Key { get; set; } = "";
        public string? Value { get; set; }
    }
}

@using ComparisonTool.Core.Comparison.Configuration
@using System.Reflection
@using System.Reflection
@using BlazorBootstrap

<style>
    .ignored-properties-container {
        margin-top: 1rem;
    }

    .ignored-properties-header {
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #dee2e6;
    }

    .ignored-properties-header h6 {
        color: #495057;
        font-weight: 600;
    }

    .ignored-properties-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .ignored-property-card {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 0.75rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.2s ease;
    }

    .ignored-property-card:hover {
        border-color: #007bff;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.1);
    }

    .property-info {
        flex: 1;
        min-width: 0;
    }

    .property-path {
        margin-bottom: 0.5rem;
    }

    .property-path code {
        font-size: 0.875rem;
        color: #6f42c1;
        background: #f8f9fa;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        word-break: break-word;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    .property-settings {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }

    .property-settings .badge {
        font-size: 0.7rem;
        padding: 0.25rem 0.5rem;
    }

    .property-actions {
        margin-left: 1rem;
    }

    .no-ignored-properties {
        text-align: center;
        padding: 2rem 1rem;
        color: #6c757d;
        background: #f8f9fa;
        border-radius: 6px;
    }

    .empty-state-icon {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        opacity: 0.5;
    }

    .empty-state-text {
        font-size: 1.1rem;
        margin-bottom: 0.5rem;
        color: #495057;
    }

    @@media (max-width: 768px) {
        .ignored-property-card {
            flex-direction: column;
            align-items: stretch;
        }
        
        .property-actions {
            margin-left: 0;
            margin-top: 0.75rem;
            align-self: flex-end;
        }
    }
</style>

<Modal @ref="propertyModal" Title="Select Properties to Ignore" Size="ModalSize.Large">
    <BodyTemplate>
        <div class="row">
            <div class="col-12">
                <div class="input-group mb-3">
                    <input type="text" class="form-control" placeholder="Search properties..."
                           @bind-value="searchTerm" @bind-value:event="oninput" />
                    <button class="btn btn-outline-secondary" type="button" @onclick="SearchProperties">
                        <i class="bi bi-search"></i> Search
                    </button>
                </div>

                <div class="mt-3">
                    <h5>All Properties</h5>
                    <div style="max-height: 300px; overflow-y: auto;">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th>Property Path</th>
                                    <th>Type</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var prop in FilteredProperties)
                                {
                                    <tr @onclick="() => SelectProperty(prop.Path)"
                                        class="@(selectedProperty == prop.Path ? "table-primary" : "")">
                                        <td>@prop.Path</td>
                                        <td>@prop.TypeName</td>
                                        <td>
                                            <button class="btn btn-sm btn-outline-primary"
                                                    @onclick:stopPropagation="true"
                                                    @onclick="() => SelectProperty(prop.Path)">
                                                Select
                                            </button>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="mt-4">
                    <h5>Selected Property Configuration</h5>
                    @if (!string.IsNullOrEmpty(selectedProperty))
                    {
                        <div class="alert alert-info">
                            <strong>@selectedProperty</strong>
                        </div>

                        <div class="card">
                            <div class="card-body">
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" id="ignoreProperty"
                                           @bind="IgnoreProperty">
                                    <label class="form-check-label" for="ignoreProperty">
                                        Ignore this property completely
                                    </label>
                                </div>

                                @if (IsCollectionProperty(selectedProperty))
                                {
                                    <div class="form-check mb-2">
                                        <input class="form-check-input" type="checkbox" id="ignoreOrdering"
                                               @bind="IgnoreCollectionOrder" disabled="@IgnoreProperty">
                                        <label class="form-check-label" for="ignoreOrdering">
                                            Ignore collection ordering
                                        </label>
                                    </div>
                                }

                                <button class="btn btn-success mt-3" @onclick="AddCurrentProperty">
                                    <i class="bi bi-plus-circle"></i> Add to Ignore List
                                </button>
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-secondary">
                            No property selected. Select a property from the list above.
                        </div>
                    }
                </div>

                <div class="mt-4">
                    <h5>Currently Ignored Properties</h5>
                    @if (IgnoredProperties.Any())
                    {
                        <div class="ignored-properties-container">
                            <div class="ignored-properties-header">
                                <h6 class="mb-0">
                                    <i class="bi bi-shield-x me-2"></i>
                                    Currently Ignored Properties
                                    <span class="badge bg-secondary ms-2">@IgnoredProperties.Count</span>
                                </h6>
                                <small class="text-muted">Properties that will be excluded from comparison</small>
                            </div>
                            
                            <div class="ignored-properties-list">
                                @foreach (var rule in IgnoredProperties.OrderBy(r => r.PropertyPath))
                                {
                                    <div class="ignored-property-card">
                                        <div class="property-info">
                                            <div class="property-path">
                                                <i class="bi bi-diagram-3 me-2 text-primary"></i>
                                                <code>@rule.PropertyPath</code>
                                            </div>
                                            <div class="property-settings">
                                                @if (rule.IgnoreCompletely)
                                                {
                                                    <span class="badge bg-danger">
                                                        <i class="bi bi-eye-slash me-1"></i>Ignore Completely
                                                    </span>
                                                }
                                                @if (rule.IgnoreCollectionOrder)
                                                {
                                                    <span class="badge bg-warning">
                                                        <i class="bi bi-arrow-down-up me-1"></i>Ignore Order
                                                    </span>
                                                }
                                            </div>
                                        </div>
                                        <div class="property-actions">
                                            <button class="btn btn-sm btn-outline-danger" 
                                                    @onclick="() => RemoveIgnoredProperty(rule.PropertyPath)"
                                                    title="Remove ignore rule">
                                                <i class="bi bi-trash"></i>
                                            </button>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="no-ignored-properties">
                            <div class="empty-state-icon">
                                <i class="bi bi-shield-check"></i>
                            </div>
                            <p class="empty-state-text">No properties are currently being ignored</p>
                            <small class="text-muted">Select properties from the tree above to add ignore rules</small>
                        </div>
                    }
                </div>
            </div>
        </div>
    </BodyTemplate>
    <FooterTemplate>
        <Button Color="ButtonColor.Secondary" @onclick="ClosePropertySelector">Close</Button>
    </FooterTemplate>
</Modal>

@code {
    [Parameter]
    public Type ModelType { get; set; }

    [Parameter]
    public List<IgnoreRule> IgnoredProperties { get; set; } = new List<IgnoreRule>();

    [Parameter]
    public EventCallback<IgnoreRule> OnPropertyAdded { get; set; }

    [Parameter]
    public EventCallback<string> OnPropertyRemoved { get; set; }

    private Modal propertyModal;
    private string selectedProperty;
    private string searchTerm = "";
    private bool IgnoreProperty { get; set; }
    private bool IgnoreCollectionOrder { get; set; }

    private List<PropertyInfo> AllProperties { get; set; } = new List<PropertyInfo>();
    private List<PropertyViewModel> FilteredProperties { get; set; } = new List<PropertyViewModel>();

    private class PropertyViewModel
    {
        public string Path { get; set; }
        public string TypeName { get; set; }
    }

    public async Task ShowAsync()
    {
        if (ModelType != null && AllProperties.Count == 0)
        {
            LoadAllProperties();
            SearchProperties();
        }

        ResetSelectionState();
        await propertyModal.ShowAsync();
    }

    private void LoadAllProperties()
    {
        var paths = GetAllPropertyPaths(ModelType);
        FilteredProperties = paths.Select(p => new PropertyViewModel
            {
                Path = p.Key,
                TypeName = GetFriendlyTypeName(p.Value)
            }).ToList();
    }

    private Dictionary<string, Type> GetAllPropertyPaths(Type type, string basePath = "", int depth = 0)
    {
        var result = new Dictionary<string, Type>();

        if (depth > 10) // Increased recursion depth limit to handle deeper nesting
            return result;

        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            string path = string.IsNullOrEmpty(basePath) ? prop.Name : $"{basePath}.{prop.Name}";
            result[path] = prop.PropertyType;

            // Recursively process complex properties
            if (!prop.PropertyType.IsPrimitive &&
                prop.PropertyType != typeof(string) &&
                prop.PropertyType != typeof(DateTime) &&
                prop.PropertyType != typeof(Guid) &&
                !prop.PropertyType.IsEnum)
            {
                // For collections, add [*] notation and process element type
                if (typeof(System.Collections.IEnumerable).IsAssignableFrom(prop.PropertyType) &&
                    prop.PropertyType != typeof(string))
                {
                    Type elementType = null;

                    if (prop.PropertyType.IsGenericType)
                    {
                        var genericArgs = prop.PropertyType.GetGenericArguments();
                        if (genericArgs.Length > 0)
                            elementType = genericArgs[0];
                    }
                    else if (prop.PropertyType.IsArray)
                    {
                        elementType = prop.PropertyType.GetElementType();
                    }

                    if (elementType != null &&
                        // Process all element types (even primitive ones), just not strings directly
                        // This ensures we include things like Summary.Id even if Id is primitive
                        (elementType != typeof(string)))
                    {
                        // Add collection path
                        result[$"{path}[*]"] = prop.PropertyType;

                        // Log collection path for debugging
                        Console.WriteLine($"Adding collection path: {path}[*] of type {elementType.Name}");

                        // Process element type properties
                        // For complex element types, we need to go deeper to find all nested properties
                        // This especially helps with nested objects inside collection items
                        var childProps = GetAllPropertyPaths(elementType, $"{path}[*]", depth + 1);
                        foreach (var childProp in childProps)
                        {
                            // Log child property of collection for debugging
                            Console.WriteLine($"  - Adding collection sub-property: {childProp.Key}");
                            result[childProp.Key] = childProp.Value;
                        }
                    }
                }
                else
                {
                    // Process regular complex type
                    var childProps = GetAllPropertyPaths(prop.PropertyType, path, depth + 1);
                    foreach (var childProp in childProps)
                    {
                        result[childProp.Key] = childProp.Value;
                    }
                }
            }
        }

        return result;
    }

    private void SearchProperties()
    {
        Console.WriteLine($"Searching for: {searchTerm}");

        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            FilteredProperties = FilteredProperties.ToList();
        }
        else
        {
            FilteredProperties = FilteredProperties
                .Where(p => p.Path.Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
                .ToList();
        }

        StateHasChanged();
    }

    private void SelectProperty(string propertyPath)
    {
        Console.WriteLine($"Selected property: {propertyPath}");
        selectedProperty = propertyPath;

        var existingRule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == propertyPath);
        if (existingRule != null)
        {
            IgnoreProperty = existingRule.IgnoreCompletely;
            IgnoreCollectionOrder = existingRule.IgnoreCollectionOrder;
        }
        else
        {
            // Default values when selecting a new property
            IgnoreProperty = false; // Default to NOT ignore completely
            IgnoreCollectionOrder = false;
        }

        StateHasChanged();
    }

    private void ResetSelectionState()
    {
        selectedProperty = null;
        IgnoreProperty = false;
        IgnoreCollectionOrder = false;
    }

    private async Task AddCurrentProperty()
    {
        if (string.IsNullOrEmpty(selectedProperty))
            return;

        var rule = new IgnoreRule
            {
                PropertyPath = selectedProperty,
                IgnoreCompletely = IgnoreProperty,
                IgnoreCollectionOrder = IgnoreCollectionOrder
            };

        // Remove existing rule for this property if it exists
        var existingRule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == selectedProperty);
        if (existingRule != null)
        {
            IgnoredProperties.Remove(existingRule);
        }

        IgnoredProperties.Add(rule);

        await OnPropertyAdded.InvokeAsync(rule);

        ResetSelectionState();
    }

    private async Task RemoveIgnoredProperty(string propertyPath)
    {
        var rule = IgnoredProperties.FirstOrDefault(p => p.PropertyPath == propertyPath);
        if (rule != null)
        {
            IgnoredProperties.Remove(rule);
            await OnPropertyRemoved.InvokeAsync(propertyPath);
        }
    }

    private void ClosePropertySelector()
    {
        propertyModal.HideAsync();
    }

    private bool IsCollectionProperty(string propertyPath)
    {
        return propertyPath.Contains("[") ||
               propertyPath.EndsWith("List") ||
               propertyPath.EndsWith("Collection") ||
               propertyPath.EndsWith("Array");
    }

    private bool IsStringProperty(string propertyPath)
    {
        var prop = FilteredProperties.FirstOrDefault(p => p.Path == propertyPath);
        return prop?.TypeName == "string";
    }

    private bool IsNumericProperty(string propertyPath)
    {
        var prop = FilteredProperties.FirstOrDefault(p => p.Path == propertyPath);
        var typeName = prop?.TypeName;

        return typeName == "int" ||
               typeName == "double" ||
               typeName == "decimal" ||
               typeName == "float" ||
               typeName == "long";
    }

    private string GetFriendlyTypeName(Type type)
    {
        if (type == typeof(int)) return "int";
        if (type == typeof(string)) return "string";
        if (type == typeof(bool)) return "bool";
        if (type == typeof(double)) return "double";
        if (type == typeof(decimal)) return "decimal";
        if (type == typeof(float)) return "float";
        if (type == typeof(DateTime)) return "datetime";
        if (type == typeof(Guid)) return "guid";

        if (typeof(System.Collections.IEnumerable).IsAssignableFrom(type) && type != typeof(string))
        {
            Type elementType = null;

            if (type.IsGenericType)
            {
                var genericArgs = type.GetGenericArguments();
                if (genericArgs.Length > 0)
                    elementType = genericArgs[0];
            }
            else if (type.IsArray)
            {
                elementType = type.GetElementType();
            }

            if (elementType != null)
                return $"List<{GetFriendlyTypeName(elementType)}>";
            else
                return "Collection";
        }

        return type.Name;
    }

    private string GetIgnoreRuleDescription(IgnoreRule rule)
    {
        var options = new List<string>();

        if (rule.IgnoreCompletely)
            options.Add("ignore completely");

        if (rule.IgnoreCollectionOrder)
            options.Add("ignore order");

        return options.Any() ? string.Join(", ", options) : "No specific rules";
    }
}
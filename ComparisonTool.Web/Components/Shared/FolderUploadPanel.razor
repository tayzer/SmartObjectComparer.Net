@namespace ComparisonTool.Web.Components.Shared
@inject IJSRuntime JSRuntime

<div class="form-group mt-3">
    <label>@Label</label>
    <div class="d-flex flex-column gap-2">
        <div class="d-flex gap-2">
            <InputFile class="form-control" OnChange="HandleFileUpload" multiple />
            <button class="btn btn-outline-primary" @onclick="BrowseFolder" type="button">
                <i class="bi bi-folder"></i> Select Folder
            </button>
            <span class="badge bg-info d-flex align-items-center">
                @if (Files.Count > 0)
                {
                    <span>@Files.Count files</span>
                }
            </span>
        </div>
        <div id="folderUploadElement_@GetHashCode()" style="display:none;">
            <InputFile OnChange="HandleFolderUpload" multiple directory webkitdirectory />
        </div>
    </div>

    @if (IsProcessing)
    {
        <div class="mt-3">
            <div class="progress" style="height: 20px;">
                <div class="progress-bar progress-bar-striped progress-bar-animated"
                     role="progressbar"
                     style="width: @ProgressPercentage%;">
                    @ProcessingStatus
                </div>
            </div>
            <small class="text-muted">@ProcessingStatus</small>
        </div>
    }

    @if (Files.Any())
    {
        <div class="mt-3">
            <div class="card">
                <div class="card-header bg-light d-flex justify-content-between align-items-center">
                    <span>Files (@Files.Count)</span>
                    <div>
                        <button class="btn btn-sm btn-outline-danger" @onclick="ClearAllFiles">
                            Clear All
                        </button>
                    </div>
                </div>
                <div style="max-height: 200px; overflow-y: auto;">
                    @if (Files.Count > 50)
                    {
                        <div class="p-3 text-center">
                            <p>@Files.Count files selected.</p>
                            <p><small class="text-muted">File list not shown for performance reasons.</small></p>
                            @if (HasMultipleFolders)
                            {
                                <div class="mt-2 alert alert-info">
                                    <i class="bi bi-info-circle me-2"></i> Files are from multiple folders
                                </div>
                            }
                        </div>
                    }
                    else
                    {
                        <ul class="list-group list-group-flush">
                            @foreach (var folderGroup in GetFolderGroups().Take(5))
                            {
                                <li class="list-group-item bg-light">
                                    <small><strong>@(string.IsNullOrEmpty(folderGroup.Key) ? "Root" : folderGroup.Key)</strong></small>
                                </li>

                                @foreach (var file in folderGroup.Take(10))
                                {
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        <div>
                                            <small>@GetFileNameOnly(file.FileName)</small>
                                        </div>
                                        <button class="btn btn-sm btn-danger" @onclick="() => RemoveFile(file)">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </li>
                                }

                                @if (folderGroup.Count() > 10)
                                {
                                    <li class="list-group-item text-center">
                                        <small>And @(folderGroup.Count() - 10) more files in this folder...</small>
                                    </li>
                                }
                            }

                            @if (GetFolderGroups().Count() > 5)
                            {
                                <li class="list-group-item text-center">
                                    <small>And @(GetFolderGroups().Count() - 5) more folders...</small>
                                </li>
                            }
                        </ul>
                    }
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Parameter]
    public string Label { get; set; }

    [Parameter]
    public List<(MemoryStream Stream, string FileName)> Files { get; set; } = new();

    [Parameter]
    public EventCallback<List<(MemoryStream Stream, string FileName)>> OnFilesChanged { get; set; }

    private bool IsProcessing { get; set; } = false;
    private int ProcessedFiles { get; set; } = 0;
    private int TotalFiles { get; set; } = 0;
    private string ProcessingStatus => $"Processed {ProcessedFiles} of {TotalFiles} files";
    private double ProgressPercentage => TotalFiles == 0 ? 0 : (double)ProcessedFiles / TotalFiles * 100;
    private bool HasMultipleFolders => GetFolderGroups().Count() > 1;

    private async Task BrowseFolder()
    {
        // Trigger the hidden input with directory attribute
        string elementId = $"folderUploadElement_{GetHashCode()}";
        await JSRuntime.InvokeVoidAsync("document.querySelector", $"#{elementId} input").AsTask();
        await JSRuntime.InvokeVoidAsync("clickElement", $"#{elementId} input");
    }

    private IEnumerable<IGrouping<string, (MemoryStream Stream, string FileName)>> GetFolderGroups()
    {
        return Files
            .GroupBy(f => GetFolderPath(f.FileName))
            .OrderBy(g => g.Key);
    }

    private string GetFolderPath(string fullPath)
    {
        // Extract folder path from full file path
        int lastSlashIndex = fullPath.LastIndexOf('/');
        if (lastSlashIndex < 0)
            lastSlashIndex = fullPath.LastIndexOf('\\');

        if (lastSlashIndex < 0)
            return string.Empty;

        return fullPath.Substring(0, lastSlashIndex);
    }

    private string GetFileNameOnly(string fullPath)
    {
        // Extract filename without the path
        int lastSlashIndex = fullPath.LastIndexOf('/');
        if (lastSlashIndex < 0)
            lastSlashIndex = fullPath.LastIndexOf('\\');

        if (lastSlashIndex < 0 || lastSlashIndex >= fullPath.Length - 1)
            return fullPath;

        return fullPath.Substring(lastSlashIndex + 1);
    }

    private async Task HandleFileUpload(InputFileChangeEventArgs e)
    {
        await ProcessUploadedFiles(e.GetMultipleFiles(), false);
    }

    private async Task HandleFolderUpload(InputFileChangeEventArgs e)
    {
        await ProcessUploadedFiles(e.GetMultipleFiles(), true);
    }

    private async Task ProcessUploadedFiles(IReadOnlyList<IBrowserFile> selectedFiles, bool isFolder)
    {
        if (selectedFiles.Count == 0)
            return;

        try
        {
            IsProcessing = true;
            ProcessedFiles = 0;
            TotalFiles = selectedFiles.Count;
            StateHasChanged();

            // Set reasonable limits
            var maxFileSize = 50 * 1024 * 1024; // 50MB per file
            var batchSize = 50; // Process files in batches of 50

            // Create a temporary list that we'll fill in batches
            var updatedFiles = new List<(MemoryStream Stream, string FileName)>(Files);

            // Number of batches we'll need to process
            int totalBatches = (selectedFiles.Count + batchSize - 1) / batchSize;
            int xmlFileCount = 0;

            for (int batch = 0; batch < totalBatches; batch++)
            {
                int startIdx = batch * batchSize;
                int endIdx = Math.Min(startIdx + batchSize, selectedFiles.Count);

                // Process this batch
                for (int i = startIdx; i < endIdx; i++)
                {
                    var file = selectedFiles[i];

                    // Skip files that are too large
                    if (file.Size > maxFileSize)
                    {
                        ProcessedFiles++;
                        StateHasChanged();
                        continue;
                    }

                    // Only process XML files - we can modify this filter as needed
                    bool isXmlFile = file.Name.EndsWith(".xml", StringComparison.OrdinalIgnoreCase);
                    if (!isXmlFile)
                    {
                        ProcessedFiles++;
                        StateHasChanged();
                        continue;
                    }

                    xmlFileCount++;

                    try
                    {
                        // Process XML file
                        var memoryStream = new MemoryStream();
                        await file.OpenReadStream(maxFileSize).CopyToAsync(memoryStream);
                        memoryStream.Position = 0;

                        // For folder uploads, preserve the full path
                        string fileName = isFolder ? file.Name : GetFileNameOnly(file.Name);
                        updatedFiles.Add((Stream: memoryStream, FileName: fileName));
                    }
                    catch (Exception ex)
                    {
                        await JSRuntime.InvokeVoidAsync("console.error", $"Error processing {file.Name}: {ex.Message}");
                    }

                    ProcessedFiles++;
                    if (ProcessedFiles % 10 == 0 || ProcessedFiles == TotalFiles)
                    {
                        StateHasChanged();
                    }
                }

                // Update UI periodically and allow for garbage collection
                if (batch % 2 == 0 || batch == totalBatches - 1)
                {
                    Files = updatedFiles.OrderBy(f => f.FileName).ToList();
                    await OnFilesChanged.InvokeAsync(Files);
                    StateHasChanged();

                    // Give the UI a chance to update
                    await Task.Delay(10);
                }
            }

            // Final update
            Files = updatedFiles.OrderBy(f => f.FileName).ToList();
            await OnFilesChanged.InvokeAsync(Files);

            // Inform user about non-XML files that were skipped
            int skippedFiles = selectedFiles.Count - xmlFileCount;
            if (skippedFiles > 0)
            {
                await JSRuntime.InvokeVoidAsync("alert", $"Loaded {xmlFileCount} XML files. Skipped {skippedFiles} non-XML files.");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error loading files: {ex.Message}");
        }
        finally
        {
            IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task RemoveFile((MemoryStream Stream, string FileName) file)
    {
        var updatedFiles = Files.Where(f => f.FileName != file.FileName).ToList();
        Files = updatedFiles;
        await OnFilesChanged.InvokeAsync(updatedFiles);
    }

    private async Task ClearAllFiles()
    {
        Files.Clear();
        await OnFilesChanged.InvokeAsync(Files);
    }
}
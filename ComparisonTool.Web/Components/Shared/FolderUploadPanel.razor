@namespace ComparisonTool.Web.Components.Shared
@using MudBlazor
@inject IJSRuntime JSRuntime
@using Microsoft.JSInterop
@implements IDisposable

<MudStack Spacing="2" Class="mt-3">
    <MudText Typo="Typo.subtitle2">@Label</MudText>
    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
        <InputFile class="mud-input-outlined" OnChange="HandleFileUpload" multiple style="flex: 1;" />
        <MudButton Variant="Variant.Outlined" 
                   Color="Color.Primary"
                   StartIcon="@Icons.Material.Filled.Folder"
                   OnClick="TriggerFolderUpload">
            Select Folder
        </MudButton>
    </MudStack>
    <!-- Hidden folder input for JS batch upload -->
    <input type="file" id="jsFolderInput_@_folderInputId" style="display:none" multiple webkitdirectory directory />

    @if (IsProcessing)
    {
        <MudStack Spacing="1" Class="mt-3">
            <MudProgressLinear Value="@ProgressPercentage" Color="Color.Primary" Striped="true" Size="Size.Large">
                <MudText Typo="Typo.caption">@ProcessingStatus</MudText>
            </MudProgressLinear>
            <MudText Typo="Typo.caption" Color="Color.Secondary">@ProcessingStatus</MudText>
        </MudStack>
    }

    @if (Files.Any())
    {
        <MudPaper Outlined="true" Class="mt-3">
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="pa-2 mud-background-gray">
                <MudText Typo="Typo.body2">Files (@Files.Count)</MudText>
                <MudButton Variant="Variant.Outlined" 
                           Size="Size.Small"
                           Color="Color.Error"
                           StartIcon="@Icons.Material.Filled.DeleteSweep"
                           OnClick="ClearAllFiles">
                    Clear All
                </MudButton>
            </MudStack>
            <div style="max-height: 200px; overflow-y: auto;">
                @if (Files.Count > 50)
                {
                    <MudStack Class="pa-3" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.body1">@Files.Count files selected.</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">File list not shown for performance reasons.</MudText>
                        @if (HasMultipleFolders)
                        {
                            <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Class="mt-2">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                    <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" />
                                    <MudText>Files are from multiple folders</MudText>
                                </MudStack>
                            </MudAlert>
                        }
                    </MudStack>
                }
                else
                {
                    <MudList T="string" Dense="true">
                        @foreach (var folderGroup in GetFolderGroups().Take(5))
                        {
                            <MudListSubheader>
                                <MudText Typo="Typo.caption"><strong>@(string.IsNullOrEmpty(folderGroup.Key) ? "Root" : folderGroup.Key)</strong></MudText>
                            </MudListSubheader>

                            @foreach (var file in folderGroup.Take(10))
                            {
                                <MudListItem T="string">
                                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                        <MudText Typo="Typo.body2">@GetFileNameOnly(file)</MudText>
                                        <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                       Size="Size.Small"
                                                       Color="Color.Error"
                                                       OnClick="@(() => RemoveFile(file))" />
                                    </MudStack>
                                </MudListItem>
                            }

                            @if (folderGroup.Count() > 10)
                            {
                                <MudListItem T="string">
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Style="text-align: center;">
                                        And @(folderGroup.Count() - 10) more files in this folder...
                                    </MudText>
                                </MudListItem>
                            }
                        }

                        @if (GetFolderGroups().Count() > 5)
                        {
                            <MudListItem T="string">
                                <MudText Typo="Typo.caption" Color="Color.Secondary" Style="text-align: center;">
                                    And @(GetFolderGroups().Count() - 5) more folders...
                                </MudText>
                            </MudListItem>
                        }
                    </MudList>
                }
            </div>
        </MudPaper>
    }
</MudStack>

@code {
    [Parameter]
    public string Label { get; set; } = string.Empty;

    [Parameter]
    public List<string> Files { get; set; } = new();

    [Parameter]
    public EventCallback<List<string>> OnFilesChanged { get; set; }

    private bool IsProcessing { get; set; } = false;
    private int ProcessedFiles { get; set; } = 0;
    private int TotalFiles { get; set; } = 0;
    private string ProcessingStatus => $"Processed {ProcessedFiles} of {TotalFiles} files";
    private double ProgressPercentage => TotalFiles == 0 ? 0 : (double)ProcessedFiles / TotalFiles * 100;
    private bool HasMultipleFolders => GetFolderGroups().Count() > 1;

    private string _folderInputId = Guid.NewGuid().ToString("N");
    private DotNetObjectReference<FolderUploadPanel>? _dotNetRef;

    protected override void OnInitialized()
    {
        _dotNetRef = DotNetObjectReference.Create(this);
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
    }

    private async Task TriggerFolderUpload()
    {
        string fullInputId = $"jsFolderInput_{_folderInputId}";
        // Only trigger the input dialog; upload will be handled by JS after user selects files
        await JSRuntime.InvokeVoidAsync("triggerFolderInput", fullInputId, 25, _dotNetRef);
    }

    [JSInvokable]
    public Task OnBatchUploadProgress(int uploaded, int total)
    {
        IsProcessing = true;
        ProcessedFiles = uploaded;
        TotalFiles = total;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnBatchUploadComplete(string fileListJson)
    {
        IsProcessing = false;
        // Parse the JSON string returned from the backend (should be { uploaded: N, files: [ ... ] })
        var fileList = System.Text.Json.JsonSerializer.Deserialize<UploadResponse>(fileListJson);
        Files = fileList?.files ?? new List<string>();
        await OnFilesChanged.InvokeAsync(Files);
        StateHasChanged();
    }

    [JSInvokable]
    public Task OnBatchUploadError(string error)
    {
        IsProcessing = false;
        StateHasChanged();
        JSRuntime.InvokeVoidAsync("alert", $"Batch upload error: {error}");
        return Task.CompletedTask;
    }

    private async Task HandleFileUpload(InputFileChangeEventArgs e)
    {
        await ProcessUploadedFiles(e.GetMultipleFiles(), false);
    }

    private async Task ProcessUploadedFiles(IReadOnlyList<IBrowserFile> selectedFiles, bool isFolder)
    {
        if (selectedFiles.Count == 0)
            return;

        try
        {
            IsProcessing = true;
            ProcessedFiles = 0;
            TotalFiles = selectedFiles.Count;
            StateHasChanged();

            // Set reasonable limits
            var maxFileSize = 50 * 1024 * 1024; // 50MB per file
            var batchSize = 25; // Process files in batches of 25

            int totalBatches = (selectedFiles.Count + batchSize - 1) / batchSize;
            int xmlFileCount = 0;
            int skippedFiles = 0;

            for (int batch = 0; batch < totalBatches; batch++)
            {
                int startIdx = batch * batchSize;
                int endIdx = Math.Min(startIdx + batchSize, selectedFiles.Count);
                var batchFileNames = new List<string>();

                for (int i = startIdx; i < endIdx; i++)
                {
                    var file = selectedFiles[i];
                    if (file.Size > maxFileSize)
                    {
                        skippedFiles++;
                        continue;
                    }
                    bool isSupportedFile = file.Name.EndsWith(".xml", StringComparison.OrdinalIgnoreCase) || 
                                           file.Name.EndsWith(".json", StringComparison.OrdinalIgnoreCase);
                    if (!isSupportedFile)
                    {
                        skippedFiles++;
                        continue;
                    }
                    xmlFileCount++;
                    string fileName = isFolder ? file.Name : GetFileNameOnly(file.Name);
                    batchFileNames.Add(fileName);
                }

                ProcessedFiles = Math.Min(endIdx, selectedFiles.Count);
                StateHasChanged();
                await Task.Delay(10); // Let UI update
            }

            // Update file list with just the file names (not streams)
            Files = selectedFiles
                .Where(f => (f.Name.EndsWith(".xml", StringComparison.OrdinalIgnoreCase) || 
                            f.Name.EndsWith(".json", StringComparison.OrdinalIgnoreCase)) && 
                            f.Size <= maxFileSize)
                .Select(f => isFolder ? f.Name : GetFileNameOnly(f.Name))
                .ToList();
            await OnFilesChanged.InvokeAsync(Files);

            if (skippedFiles > 0)
            {
                await JSRuntime.InvokeVoidAsync("alert", $"Loaded {xmlFileCount} supported files (XML/JSON). Skipped {skippedFiles} unsupported or too large files.");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error loading files: {ex.Message}");
        }
        finally
        {
            IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task RemoveFile(string file)
    {
        var updatedFiles = Files.Where(f => f != file).ToList();
        Files = updatedFiles;
        await OnFilesChanged.InvokeAsync(updatedFiles);
    }

    private async Task ClearAllFiles()
    {
        Files.Clear();
        await OnFilesChanged.InvokeAsync(Files);
    }

    private IEnumerable<IGrouping<string, string>> GetFolderGroups()
    {
        return Files
            .GroupBy(f => GetFolderPath(f))
            .OrderBy(g => g.Key);
    }

    private string GetFolderPath(string fullPath)
    {
        // Extract folder path from full file path
        int lastSlashIndex = fullPath.LastIndexOf('/');
        if (lastSlashIndex < 0)
            lastSlashIndex = fullPath.LastIndexOf('\\');

        if (lastSlashIndex < 0)
            return string.Empty;

        return fullPath.Substring(0, lastSlashIndex);
    }

    private string GetFileNameOnly(string fullPath)
    {
        // Extract filename without the path
        int lastSlashIndex = fullPath.LastIndexOf('/');
        if (lastSlashIndex < 0)
            lastSlashIndex = fullPath.LastIndexOf('\\');

        if (lastSlashIndex < 0 || lastSlashIndex >= fullPath.Length - 1)
            return fullPath;

        return fullPath.Substring(lastSlashIndex + 1);
    }

    private class UploadResponse
    {
        public int uploaded { get; set; }
        public List<string>? files { get; set; }
    }
}